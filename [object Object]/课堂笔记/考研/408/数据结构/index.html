<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构 | 时间·线</title><meta name="keywords" content="课堂笔记,考研,408"><meta name="author" content="HiDolen"><meta name="copyright" content="HiDolen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 绪论  1.1 数据结构的基本概念 术语，  数据，字符符号集合，是计算机程序加工的原料 数据元素，数据的基本单位。数据元素由数据项组成，数据项是构成数据元素的最小单位  例如，学生记录是一个数据元素，由学号、姓名等数据项构成   数据对象，具有相同性质的数据元素的集合  是数据的子集，例如整数数据对象 N&#x3D;{0, ±1, ±2, …}   数据类型  原子类型，其值不可再分 结构类型，">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/[object%20Object]/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="时间·线">
<meta property="og:description" content="第一章 绪论  1.1 数据结构的基本概念 术语，  数据，字符符号集合，是计算机程序加工的原料 数据元素，数据的基本单位。数据元素由数据项组成，数据项是构成数据元素的最小单位  例如，学生记录是一个数据元素，由学号、姓名等数据项构成   数据对象，具有相同性质的数据元素的集合  是数据的子集，例如整数数据对象 N&#x3D;{0, ±1, ±2, …}   数据类型  原子类型，其值不可再分 结构类型，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-09-08T06:36:17.000Z">
<meta property="article:modified_time" content="2022-09-08T06:42:40.675Z">
<meta property="article:author" content="HiDolen">
<meta property="article:tag" content="课堂笔记">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/[object%20Object]/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-08 14:42:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">110</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">时间·线</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-08T06:36:17.000Z" title="发表于 2022-09-08 14:36:17">2022-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-08T06:42:40.675Z" title="更新于 2022-09-08 14:42:40">2022-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">课堂笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/">考研</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/">408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章-绪论"><a class="markdownIt-Anchor" href="#第一章-绪论"></a> 第一章 绪论</h2>
<h3 id="11-数据结构的基本概念"><a class="markdownIt-Anchor" href="#11-数据结构的基本概念"></a> 1.1 数据结构的基本概念</h3>
<p>术语，</p>
<ul>
<li><strong>数据</strong>，字符符号集合，是计算机程序加工的原料</li>
<li><strong>数据元素</strong>，<strong>数据</strong>的基本单位。数据元素由数据项组成，<strong>数据项</strong>是构成数据元素的最小单位
<ul>
<li>例如，学生记录是一个数据元素，由学号、姓名等数据项构成</li>
</ul>
</li>
<li><strong>数据对象</strong>，具有相同性质的<strong>数据元素</strong>的集合
<ul>
<li>是数据的子集，例如整数数据对象 N={0, ±1, ±2, …}</li>
</ul>
</li>
<li><strong>数据类型</strong>
<ul>
<li>原子类型，其值不可再分</li>
<li>结构类型，可再分为若干数据类型</li>
<li>抽象数据类型，抽象数据</li>
</ul>
</li>
<li><strong>数据结构</strong>，是相互之间存在特定关系的<strong>数据元素</strong>的集合
<ul>
<li>存储数据时，通常要存储各数据元素的值，以及数据元素之间的关系</li>
<li>数据元素之间的关系称为结构，包括三个方面的内容：
<ul>
<li>逻辑结构、存储结构、数据的运算</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据结构三要素，</p>
<ul>
<li><strong>逻辑结构</strong>，与数据的存储无关，独立于计算机
<ul>
<li>线性结构，数据元素之间只存在一对一的关系，例如表、栈、队列、数组
<ul>
<li><em>注意</em>，像是栈，是一种抽象数据结构，可以采用顺序存储或链式存储。它不是存储结构</li>
</ul>
</li>
<li>非线性结构，例如集合、树、图
<ul>
<li>集合，数据元素之间除 “同属一个集合” 外，别无其他关系</li>
<li>树形结构，数据元素之间存在一对多的关系</li>
<li>图状结构/网状结构，数据元素之间存在多对多的关系</li>
</ul>
</li>
</ul>
</li>
<li><strong>存储结构</strong>，包括：顺序存储、链式存储、索引存储、散列存储
<ul>
<li>散列存储/哈希存储，根据关键字计算元素的地址。检索、增删结点很快，但可能出现冲突</li>
</ul>
</li>
<li>数据的运算，逻辑结构指出其功能（设计），存储结构指出其具体操作步骤（算法实现）</li>
</ul>
<h3 id="12-算法和算法评价"><a class="markdownIt-Anchor" href="#12-算法和算法评价"></a> 1.2 算法和算法评价</h3>
<p>算法，是指令的有限序列。其重要特性：</p>
<ul>
<li>有穷性</li>
<li>确定性，指令含义确切，相同输入会得出相同输出</li>
<li>可行性，算法中的操作通过有限次基本运算实现</li>
<li>输入、输出</li>
</ul>
<p>算法好坏的衡量指标：</p>
<ul>
<li>正确性，正确地解决问题</li>
<li>可读性，算法的可读性</li>
<li>健壮性，鲁棒性</li>
<li>效率与低存储量需求，效率是指执行的时间，存储量需求是算法执行需要的最大存储空间</li>
</ul>
<p>算法效率的度量：</p>
<ul>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>
<ul>
<li>用基本运算的频度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 来衡量（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为问题的规模）：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 是指 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的数量级。具体来说，应满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>C</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)≤Cf(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 为某常数</li>
</ul>
</li>
<li>又会分为：最坏时间复杂度、最好时间复杂度、平均时间复杂度（所有可能输入等概率）</li>
<li>运算规则：
<ul>
<li>加法规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(f(n))+O(g(n))=O(max(f(n),g(n)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>乘法规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>×</mo><mi>O</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>×</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(f(n))×O(g(n))=O(f(n)×g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>常见的渐进时间复杂度：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(\log_2n)&lt;O(n)&lt;O(n\log_2n)&lt;O(n^2)&lt;O(2^n)&lt;O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
<li>空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O(g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>算法原地工作，指算法所需的辅助空间为常数，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
<h2 id="第二章-线性表"><a class="markdownIt-Anchor" href="#第二章-线性表"></a> 第二章 线性表</h2>
<p>考试重点为代码设计。</p>
<h3 id="21-线性表的定义-基本操作"><a class="markdownIt-Anchor" href="#21-线性表的定义-基本操作"></a> 2.1 线性表的定义、基本操作</h3>
<p>线性表内容：</p>
<ul>
<li>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 命名线性表，则表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L=(a_1, a_2, … a_i, a_{i+1}, …, a_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为表长。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表头元素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表尾元素（<strong>以 1 开始</strong>）</li>
<li>每个元素的逻辑关系：直接前驱，直接后继</li>
</ul>
<p>注意：</p>
<ul>
<li>线性表与顺序表、链表不同，前者是逻辑结构，后者是存储结构</li>
<li><strong>集合不是线性表</strong>。线性表需要元素之间拥有前后驱关系</li>
</ul>
<p>线性表的基本操作：</p>
<ul>
<li><code>InitList(&amp;L)</code>，初始化表，构造一个空线性表</li>
<li><code>Length(L)</code>，表长</li>
<li><code>LocateElem(L, e)</code>，按值查找</li>
<li><code>GetElem(L, i)</code>，按下表查找</li>
<li><code>ListInsert(&amp;L, i, e)</code>，在下标 i 处插入元素</li>
<li><code>ListDelete(&amp;L, i, &amp;e)</code>，删除下标 i 处的元素，并返回元素的值</li>
<li><code>PrintList(L)</code>，打印表的所有元素</li>
<li><code>Empty(L)</code>，判断是否为空，为空返回 true</li>
<li><code>DestroyList(&amp;L)</code>，释放线性表内存空间，销毁表</li>
</ul>
<h3 id="22-线性表的顺序表示"><a class="markdownIt-Anchor" href="#22-线性表的顺序表示"></a> 2.2 线性表的顺序表示</h3>
<p>顺序表，线性表的顺序存储。</p>
<ul>
<li>存储地址连续
<ul>
<li>即，逻辑顺序与其物理顺序相同</li>
</ul>
</li>
<li>线性表的顺序存储结构是一种随机存取的存储结构。高级程序语言中一般用 数组 描述</li>
</ul>
<p>与顺序表有关的代码:</p>
<ul>
<li>顺序表 可描述为：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;             <span class="comment">// 顺序表当前长度</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>
</li>
<li>动态分配空间的顺序表：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType *data;</span><br><span class="line">  <span class="type">int</span> MaxSize, length;        <span class="comment">// 数组的最大容量、顺序表当前长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="comment">// 分配空间的方法：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100</span></span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*InitSize); <span class="comment">// C</span></span><br><span class="line">L.data = new ElemType[InitSize]                        <span class="comment">// C++</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>顺序表的相关操作，</p>
<ul>
<li>插入
<ul>
<li>首先判断插入位置 <code>i</code> 是否合法，然后判断存储空间是否已满</li>
<li>之后的元素往后移，然后插入元素，表长度加 1</li>
</ul>
</li>
<li>删除
<ul>
<li>判断 <code>i</code> 是否有效，然后元素前移，表长度减 1</li>
</ul>
</li>
<li>按值查找</li>
</ul>
<h3 id="23-线性表的链式表示"><a class="markdownIt-Anchor" href="#23-线性表的链式表示"></a> 2.3 线性表的链式表示</h3>
<p><strong>单链表</strong>，线性表的链式存储。链表结点需额外存储指向后继的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList</span><br></pre></td></tr></table></figure>
<p>头结点，不存储信息、指针指向头指针的结点。</p>
<ul>
<li>带来的好处是，链表第一个结点的插入和删除操作统一、空表与非空表的操作统一</li>
</ul>
<p>建立单链表的大致步骤，</p>
<ul>
<li>使用类似 <code>LNode *s = (LNode*)malloc(sizeof(LNode))</code> 的语句申请空间</li>
<li>对 <code>s-&gt;data</code> <code>s-&gt;next</code> 赋值</li>
</ul>
<p>删除结点的大致过程，</p>
<ul>
<li>对结点 <code>*q</code> 使用 <code>free(q)</code></li>
</ul>
<p><strong>双链表</strong>，每个结点有两个指针 <code>*prior</code> <code>*next</code>。</p>
<p>循环链表，最后一结点的指针指向头结点。</p>
<p>循环双链表，双链表的循环模式。</p>
<p><strong>静态链表</strong>，借助数组来描述线性表的链式存储结构。用下标代（游标）替指针。</p>
<ul>
<li>结束标志，下标 = -1</li>
</ul>
<h2 id="第三章-栈-队列和数组"><a class="markdownIt-Anchor" href="#第三章-栈-队列和数组"></a> 第三章 栈、队列和数组</h2>
<h3 id="31-栈stack"><a class="markdownIt-Anchor" href="#31-栈stack"></a> 3.1 栈（Stack）</h3>
<p>栈，一种线性表，只允许在其一端进行插入删除操作。</p>
<ul>
<li>特性：后进先出（LIFO，Last In First Out）</li>
<li><strong>栈顶</strong>（Top），入栈与出栈的位置</li>
<li>栈底（Bottom）</li>
</ul>
<p>栈的基本操作：</p>
<ul>
<li><code>InitStack(&amp;S)</code>，初始化一个空栈</li>
<li><code>StackEmpty(S)</code>，判断一个栈是否为空，为空则返回 true</li>
<li><code>Push(&amp;S, x)</code>，进栈
<ul>
<li>先判断是否栈满</li>
</ul>
</li>
<li><code>Pop(&amp;S, &amp;x)</code>，出栈，返回值写入 <code>x</code>
<ul>
<li>先判断是否栈空</li>
</ul>
</li>
<li><code>GetTop(S, &amp;x)</code>，读栈顶，返回值写入 <code>x</code>
<ul>
<li>先判断是否栈空</li>
</ul>
</li>
<li><code>DestroyStack(&amp;S)</code>，销毁栈</li>
</ul>
<p>栈的存储结构：</p>
<ul>
<li>
<p>顺序栈，采用顺序存储</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="type">int</span> top;        <span class="comment">// 栈顶下标。空栈时为 -1，也可以定为 0</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>共享栈，两个顺序栈在同一块空间的两端</p>
</li>
<li>
<p>链栈，栈的链式存储结构。通常为单链，并且入栈入表头</p>
</li>
</ul>
<h3 id="32-队列queue"><a class="markdownIt-Anchor" href="#32-队列queue"></a> 3.2 队列（Queue）</h3>
<p>队列，一种线性表。只允许一端插入（入队），另一端删除（出队）。</p>
<ul>
<li>特性：先进先出（FIFO，First In First Out）</li>
<li><strong>队头</strong>（Front），出队端</li>
<li><strong>队尾</strong>（Rear），入队端</li>
</ul>
<p>队列的基本操作：</p>
<ul>
<li><code>InitQueue(&amp;Q)</code>，初始化队列</li>
<li><code>QueueEmpty(Q)</code>，判断队列是否为空，为空则返回 true</li>
<li><code>EnQueue(&amp;Q, x)</code>，入队，添加 <code>x</code>
<ul>
<li>队尾指针加 1</li>
</ul>
</li>
<li><code>DeQueue(&amp;Q, &amp;x)</code>，出队，写入 <code>x</code>
<ul>
<li>队头指针加 1</li>
</ul>
</li>
<li><code>GetHead(Q, &amp;x)</code>，读取队头元素</li>
</ul>
<p>由入队和出队过程可知，<strong>队尾比队头跑得快</strong>。</p>
<p>队列的存储结构：</p>
<ul>
<li>
<p>队列的顺序存储</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="type">int</span> front, rear; <span class="comment">// 队头和队尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>顺序队列，会出现 “假溢出问题”</li>
<li>循环队列，指针到达 MaxSize - 1 后，再前进一个位置就会回到 0
<ul>
<li>用代码 <code>Q.front = (Q.front + 1) % MaxSize</code> 实现</li>
<li><strong>一般 <code>Q.front == Q.rear</code> 为队空</strong>。队满的情况有点复杂，会分三种方案：
<ul>
<li>一种是 <code>(Q.rear + 1) % MaxSize == Q.front</code> 为队满，这会牺牲一个存储单元</li>
<li>一种是增设 <code>size</code> 存储队列中的元素个数</li>
<li>一种是增设 <code>tag</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>队列的链式存储</p>
<ul>
<li>链队列，头指针指向队头，尾指针指向队尾
<ul>
<li>通常是带头结点的单链表，否则会比较麻烦
<ul>
<li>也就是说，出队操作要读取头结点的下一个结点（<code>Q.front-&gt;next</code>）</li>
</ul>
</li>
<li><code>Q.front == Q.rear</code> 为队空。这里发现，队满情况没有循环队列的烦恼
<ul>
<li>意味着，若出队元素为最后一个元素，则需要将 <code>Q.front</code> <code>Q.rear</code> 都置为 NULL</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>双端队列，允许两段都可以进行入队和出队</p>
<ul>
<li>两端被称为<strong>前端</strong>和<strong>后端</strong></li>
<li>受限的双端队列：有一端只允许入队（输出受限）或出队（输入受限）</li>
</ul>
</li>
</ul>
<h3 id="33-栈和队列的应用"><a class="markdownIt-Anchor" href="#33-栈和队列的应用"></a> 3.3 栈和队列的应用</h3>
<p>栈，应用在括号匹配：</p>
<ul>
<li>目标是让括号 “有始有终”</li>
</ul>
<p>栈，应用在表达式求值：</p>
<ul>
<li>先转换为后缀表达式
<ul>
<li>对于中缀表示 <code>a+b</code>，后缀表示会变为 <code>ab+</code></li>
<li><code>(a+b)*(c-d)</code> 变为 <code>ab+cd-*</code></li>
<li><code>x=5</code> 变为 <code>x5=</code></li>
<li><code>x=a*b</code> 变为 <code>xab*=</code></li>
</ul>
</li>
</ul>
<p>栈，应用在递归：</p>
<ul>
<li>递归改写为非递归，通常需要借助栈</li>
<li>递归就是自己调用自己
<ul>
<li>递归模型，包含递归表达式（递归体）和边界条件（递归出口）</li>
<li>递归容易栈溢出，并且可能的重复计算导致效率不高（相同参数可能会被计算多次）</li>
</ul>
</li>
</ul>
<p>队列，应用在层次遍历：</p>
<ul>
<li>例如，对二叉树一层层遍历
<ul>
<li>每读入一个双亲结点，就把它的所有子节点入队</li>
</ul>
</li>
</ul>
<p>队列，应用在计算机系统：</p>
<ul>
<li>外存比内存较慢，用缓冲区（队列）进行协调</li>
<li>CPU 的时间片轮转调度算法，也使用队列</li>
</ul>
<h3 id="34-数组和特殊矩阵"><a class="markdownIt-Anchor" href="#34-数组和特殊矩阵"></a> 3.4 数组和特殊矩阵</h3>
<p>数组是线性表的推广，一维数组可以视为一个线性表。但数组的长度不应发生变化。</p>
<p>数组的存储结构，</p>
<ul>
<li>对于多维数组，例如二维数组，有先行后列（行优先）和先列后行（列优先）的存储方式</li>
</ul>
<p>特殊矩阵，内容具有规律的矩阵，例如对称矩阵。</p>
<p>特殊矩阵的压缩存储方法：多个值相同的元素只分配一个存储空间。</p>
<ul>
<li>对称矩阵，所有元素都满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i,j}=a_{j,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>元素可划分为：上三角区、主对角线、下三角区</li>
<li>压缩存储方法：一维数组，行优先的方式，只存放下三角区、主对角区的元素</li>
</ul>
</li>
<li>三角矩阵，两个三角区域的其中一个均为同一常量
<ul>
<li>压缩存储方法：一维数组，以行优先的方式存放三角元素，最后用一位存储常数项</li>
</ul>
</li>
<li>三对角矩阵（带状矩阵），对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|i-j|&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时均有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_{i,j}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>
<ul>
<li>呈带状分布在主对角区附近，其余位置全是 0</li>
<li>压缩存储方法：一维数组，行优先存储。除了首行末行只有 2 个元素，其他全是 3 个元素</li>
</ul>
</li>
<li>稀疏矩阵，除了少有的几个元素外，都是常数 0
<ul>
<li>采用压缩后，稀疏矩阵会失去随机存取的特性</li>
</ul>
</li>
</ul>
<h2 id="第四章-串"><a class="markdownIt-Anchor" href="#第四章-串"></a> 第四章 串</h2>
<p>就是字符串。</p>
<h3 id="41-串的定义和实现"><a class="markdownIt-Anchor" href="#41-串的定义和实现"></a> 4.1 串的定义和实现</h3>
<p>串一般记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">S=\mathrm{&#x27;}a_1a_2…a_n\mathrm{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.901892em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>，可见很像是代码里的字符串。</p>
<ul>
<li><strong>子串</strong>，串的子序列；<strong>主串</strong>，包含子串的串。</li>
<li>子串在主串中的<strong>位置</strong>，由子串第一个字符的位置决定</li>
</ul>
<p>串的存储结构，</p>
<ul>
<li>
<p>定长顺序存储</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];</span><br><span class="line">    <span class="type">int</span> length;       <span class="comment">// 串的当前长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>堆分配存储（动态分配）</p>
<ul>
<li>就是用 <code>malloc()</code> 分配空间，<code>free()</code> 释放空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">char</span> *ch;</span><br><span class="line">  <span class="type">int</span> length;         <span class="comment">// 串的当前长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>块链存储</p>
<ul>
<li>使用链表，每个结点被称为<strong>块</strong></li>
<li>结点可以多个字符，一个块链结构的每个结点有相同的结点大小
<ul>
<li>最后一个结点不满时通常用 <code>#</code> 补足</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>串的基本操作，</p>
<ul>
<li><code>StrAssign(&amp;T, chars)</code>，赋值</li>
<li><code>StrCopy(&amp;T, S)</code>，复制，从 <code>S</code> 复制到 <code>T</code></li>
<li><code>StrEmpty(S)</code>，判断是否为空，为空则返回 TRUE</li>
<li><code>StrCompare(S, T)</code>，比较字符串长度，返回 <code>len(S)</code> 减 <code>len(T)</code> 的值</li>
<li><code>StrLength(S)</code>，求长度</li>
<li><code>SubString(&amp;Sub, pos, len)</code>，截取子串，用 <code>Sub</code> 存储结果</li>
<li><code>Concat(&amp;T, S1, S2)</code>，串联接，用 <code>T</code> 存储结果（concatenate）</li>
<li><code>Index(S, T)</code>，在 <code>T</code> 中定位子串 <code>S</code> 第一次出现的位置。未找到则返回 <code>0</code></li>
<li><code>ClearString(&amp;S)</code>，清空串</li>
<li><code>DestroyString(&amp;S)</code>，销毁串</li>
</ul>
<h3 id="42-串的模式匹配"><a class="markdownIt-Anchor" href="#42-串的模式匹配"></a> 4.2 串的模式匹配</h3>
<p>模式匹配，就是查找子串位置。</p>
<ul>
<li>简单的模式匹配算法
<ul>
<li>先匹配子串第一个字符，然后匹配第二个。若不符合，指针回退</li>
<li>最坏时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 分别为子串和主串的长度</li>
<li>理论时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo><mtext>，</mtext></mrow><annotation encoding="application/x-tex">O(mn)，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span></span></span></span>实际的执行时间近似为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>串的模式匹配算法 —— <strong>KMP 算法</strong>
<ul>
<li>上一个算法在每次匹配失败时，会从头再来，导致重复劳动</li>
<li>改进的基本思想：匹配失败后，指针<strong>只进行必要的回退</strong>（用子串右移表示）
<ul>
<li>用子串右移表示，也意味着回避了指针的回退。指针只增不减</li>
</ul>
</li>
<li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>算法过程：
<ul>
<li>首先计算子串各个字符的匹配值
<ul>
<li>例如，对 <code>ababa</code>：</li>
<li><code>a</code> 匹配值为 0</li>
<li><code>ab</code> 时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo><mo>∩</mo><mo stretchy="false">{</mo><mi>b</mi><mo stretchy="false">}</mo><mo>=</mo><mtext>∅</mtext></mrow><annotation encoding="application/x-tex">\{a\}∩\{b\}=∅</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span>，匹配值为 0</li>
<li><code>aba</code> 时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mo stretchy="false">}</mo><mo>∩</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mi>a</mi><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a,ab\}∩\{a,ba\}=\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span>，交集元素最长为 1，匹配值为 1</li>
<li><code>abab</code> 时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mi>a</mi><mo stretchy="false">}</mo><mo>∩</mo><mo stretchy="false">{</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mi>a</mi><mi>b</mi><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a,ab,aba\}∩\{b,ab,bab\}=\{ab\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mclose">}</span></span></span></span>，交集元素最长为 2，匹配值为 2</li>
<li><code>ababa</code> 时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mi>a</mi><mi>b</mi><mo stretchy="false">}</mo><mo>∩</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mi>a</mi><mi>b</mi><mi>a</mi><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mi>b</mi><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a,ab,aba,abab\}∩\{a,ba,aba,baba\}=\{a,aba\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span>，交集元素最长为 3，匹配值为 3</li>
</ul>
</li>
<li>然后，进行模式匹配时，每当遇到不匹配的字符，位移 = 已匹配的字符数 - 对应匹配值
<ul>
<li>例如，对于 <code>ababa</code>，若是第二个 <code>b</code> 发生了不匹配，就取 <code>aba</code> 的匹配值 1</li>
<li>子串向右位移位移 = 3 - 1 = 2</li>
</ul>
</li>
</ul>
</li>
<li>求 next[ ] 数组：
<ul>
<li>以上算法需要查阅不匹配字符前一个匹配值，且要计算减法</li>
<li>next[ ] 直接存储左移位置。获得方法如下（右移、加 1）：
<ul>
<li>先将匹配值整体<strong>右移</strong>（解决 “查阅不匹配字符前一个匹配值”）
<ul>
<li>第一个元素用 -1 填充</li>
</ul>
</li>
<li>然后所有匹配值<strong>加 1</strong>，避免移位之后还要再后移一位用以下一趟匹配</li>
<li>此时 next[ ] 存储的是：子串第 j 位发生不匹配时，右移子串，令子串位于 next[j] 的字符移动到匹配失败位置（解决 “要计算减法”）
<ul>
<li>若 next[j] 为 0，则指针后移一位，然后从子串第一个字符开始匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>next[ ] 的改进：nextval[ ]
<ul>
<li>若是 <code>aaab</code> 这样的模式，匹配到第三个 <code>a</code> 失败后，next[ ] 会发生两次无意义比较，因为位移得到的还是必定失配的 <code>a</code></li>
<li>而 nextval[ ] 存储的是迭代后的结果，让第三个 <code>a</code> 失败后直接回到 0，而不是 2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五章-树与二叉树"><a class="markdownIt-Anchor" href="#第五章-树与二叉树"></a> 第五章 树与二叉树</h2>
<p>考试重点在遍历的代码书写，包括递归和非递归。</p>
<h3 id="51-树"><a class="markdownIt-Anchor" href="#51-树"></a> 5.1 树</h3>
<p>树，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个结点的有限集。空树，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 为 0。</p>
<ul>
<li>前驱，双亲结点；后继，孩子结点</li>
<li>祖先，双亲结点及往上；子孙，孩子结点及往下；<strong>兄弟</strong>，拥有相同双亲</li>
<li><strong>度</strong>，一个结点的孩子结点个数</li>
<li><strong>树的度</strong>，树中所有结点的度的最大值</li>
<li>有序树与无序树：各子树是否能交换左右位置</li>
<li>路径长度，两个结点间的路径所经过的边的个数；树的路径长度，根到所有结点的路径长度之和</li>
<li><strong>森林</strong>，多棵不相交的树的集合</li>
</ul>
<h3 id="52-二叉树"><a class="markdownIt-Anchor" href="#52-二叉树"></a> 5.2 二叉树</h3>
<p>二叉树，每个结点至多两颗子树的<strong>有序树</strong>。</p>
<p>二叉树是一种树形结构，所以空树也可以认作二叉树。</p>
<ul>
<li>满二叉树，除了叶子结点就都是有左右子树的结点，呈完美的金字塔形状</li>
<li>完全二叉树，可以理解为 “以行优先的顺序添加结点” 构造出的树</li>
<li>二叉排序树，左子树所有结点的值都小于右子树所有结点的值，根结点的值处在两者之间
<ul>
<li>可能是非平衡的，要注意</li>
</ul>
</li>
<li>二叉平衡树，树上的任一结点，其左右子树的深度之差不超过 1</li>
</ul>
<p>二叉树的存储结构，</p>
<ul>
<li>顺序存储结构，以行优先的顺序存储在连续空间中。<strong>强制存储为满二叉树</strong>
<ul>
<li>不存在结点的位置就用空结点占位</li>
</ul>
</li>
<li>链式存储结构，更常用的二叉树存储方式
<ul>
<li>三指针 <code>lchild</code> <code>data</code> <code>rchild</code></li>
</ul>
</li>
</ul>
<h3 id="53-二叉树的遍历和线索二叉树"><a class="markdownIt-Anchor" href="#53-二叉树的遍历和线索二叉树"></a> 5.3 二叉树的遍历和线索二叉树</h3>
<p>三种常见遍历算法，</p>
<ul>
<li>先序遍历（PreOrder）
<ul>
<li>从根结点开始，以左子树优先的形式向下遍历</li>
<li>从上到下，左优先</li>
</ul>
</li>
<li>中序遍历（InOrder）
<ul>
<li>从最左的叶结点开始向上，若双亲存在右结点，则在之后跳到右结点的最左叶结点</li>
<li>先极左，然后双亲结点，最后开始右子树</li>
</ul>
</li>
<li>后序遍历（PostOrder）
<ul>
<li>从最左的叶结点开始向上，双亲存在右结点就直接跳到右结点的最左叶结点，最后双亲结点</li>
<li>先极左，然后右子树，最后双亲结点</li>
</ul>
</li>
</ul>
<p>额外的注意要点：</p>
<ul>
<li>先序遍历与后续遍历不能共同唯一确定一棵二叉树</li>
<li>后序线索树的遍历仍然要依靠栈</li>
</ul>
<p>先序遍历的递归代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">order</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);               <span class="comment">// 这行若下移一行，就是中序遍历；下移两行，后序遍历</span></span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于中序遍历，若想用非递归的方式进行代码实现，要借助栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        Push(S, p);             <span class="comment">// 若要变成先序遍历，就把 visit(p) 放这</span></span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Pop(S, p);</span><br><span class="line">        visit(p);               <span class="comment">// 注意 visit(p)</span></span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但后序遍历的非递归实现比较复杂，要出栈访问的前提是，结点的右子树不存在或已经访问完毕。</p>
<ul>
<li>所以需要一个额外的指针，存储遍历子树时的根结点</li>
<li>第一次遇到根节点，赋值给额外指针。第二次遇到根节点（右子树遍历完成），发现额外指针等于根结点，就让根结点出栈，子树遍历完毕</li>
</ul>
<p>层次遍历，一行一行进行遍历，</p>
<ul>
<li>借助队列。先将根节点入队，然后对于每个出队结点将它的所有孩子入队<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InitQueue(Q);</span><br><span class="line">BiTree p;</span><br><span class="line">EnQueue(Q, T);</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">  DeQueue(Q, p);</span><br><span class="line">  visit(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">      EnQueue(Q, p-&gt;lchild);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">      EnQueue(Q, p-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>线索二叉树，让结点的 <code>lchild</code> <code>rchild</code> 指针存储某种遍历顺序的前驱和后继结点。</p>
<ul>
<li>线索二叉树是物理结构，二叉树是逻辑结构</li>
<li>线索二叉树是在二叉链表下思考的
<ul>
<li>每个结点除了三指针 <code>lchild</code> <code>data</code> <code>rchild</code>，还有 <code>ltag</code> <code>rtag</code></li>
<li>tag 为 0 表示指针指向的是孩子，为 1 表示指向的是前驱或后继</li>
</ul>
</li>
<li>对于树的结点：无左子树，就用 <code>lchild</code> 指向前驱结点；无右子树，就用 <code>rchild</code> 指向后继结点</li>
</ul>
<h3 id="54-树-森林"><a class="markdownIt-Anchor" href="#54-树-森林"></a> 5.4 树、森林</h3>
<p>树的存储结构，</p>
<ul>
<li>双亲表示法，用连续空间（数组）存储每个结点
<ul>
<li>每个节点额外有一个伪指针，指示双亲结点在数组的下标。根节点的伪指针为 -1</li>
<li>只能从下至上遍历。若要从上至下就需要遍历整个结构</li>
</ul>
</li>
<li>孩子表示法，数组存储每个结点，每个结点指向一个存储所有孩子结点的下标的单链表
<ul>
<li>叶子结点的孩子链表为空表</li>
</ul>
</li>
<li>孩子兄弟表示法，又称二叉树表示法，用二叉链表作为树的存储结构
<ul>
<li>首先需要<strong>树转换为二叉树</strong></li>
</ul>
</li>
</ul>
<p>树转换为二叉树的方法，</p>
<ul>
<li>对于二叉树结点，左孩子代表孩子，右孩子代表兄弟</li>
<li>有多个孩子，就一层左孩子叠一层左孩子；有多个兄弟，就一层右孩子叠一层右孩子</li>
</ul>
<p>森林转换为二叉树的方法，</p>
<ul>
<li>首先将各个树转换为二叉树</li>
<li>由于转换出的二叉树根节点的右子树必为空，就可以<strong>利用右子树空位</strong>来拼接各个二叉树</li>
</ul>
<p>树的遍历，</p>
<ul>
<li>先根遍历，先访问根再访问子树。与二叉树的先序遍历相似
<ul>
<li>若是转换为了二叉树，使用二叉树的<strong>先序遍历</strong></li>
</ul>
</li>
<li>后根遍历，先访问子树再访问根。与二叉树的后序遍历相似
<ul>
<li>若是转换为了二叉树，使用二叉树的<strong>中序遍历</strong></li>
</ul>
</li>
</ul>
<p>森林的遍历，</p>
<ul>
<li>先序遍历森林，先访问根结点
<ul>
<li>若是转换为了二叉树，使用二叉树的<strong>先序遍历</strong></li>
</ul>
</li>
<li>中序遍历森林，先访问子树
<ul>
<li>若是转换为了二叉树，使用二叉树的<strong>中序遍历</strong></li>
<li>有时也叫做后根遍历</li>
</ul>
</li>
</ul>
<h3 id="56-树与二叉树的应用哈夫曼"><a class="markdownIt-Anchor" href="#56-树与二叉树的应用哈夫曼"></a> 5.6 树与二叉树的应用（哈夫曼）</h3>
<p>权，树的结点赋予一个权，被用于计算<strong>带权路径长度</strong>。</p>
<ul>
<li>带权路径长度，结点到树根的路径长度（经过边的数量）与结点的权的乘积</li>
<li>树的带权路径长度（WPL），所有<strong>叶节点</strong>的带权路径长度之和</li>
</ul>
<p>哈夫曼树，也称最优二叉树，是<strong>带权路径长度（WPL）最小的二叉树</strong>。</p>
<p>哈夫曼树的构造，</p>
<ul>
<li>将 n 个带权结点视为 n 棵树，构成森林 F</li>
<li>选择树根权值最小的两棵树合并，新树根权值为两者的和</li>
<li>注意项：
<ul>
<li>哈夫曼树没有度为 1 的结点</li>
</ul>
</li>
</ul>
<p>哈夫曼编码，一种可变长度编码。将高频出现的字符赋以短编码可起到数据压缩的作用。</p>
<ul>
<li>是一种前缀编码</li>
<li>用哈夫曼树可以简单获得哈夫曼编码：
<ul>
<li>左孩子为 0，右孩子为 1，从上到下编码</li>
</ul>
</li>
</ul>
<p>并查集，一种集合表示方法。</p>
<ul>
<li><strong>本质上是一个数组</strong>。用下标代表集合元素，用数组元素代表所属集合</li>
<li>核心思想：<strong>用集合中的一个元素代表集合</strong>
<ul>
<li>也就是说，数组元素是数组下标</li>
</ul>
</li>
<li>初始化后，数组元素数值均为 -1；数组元素值为负数，意味着对应集合元素自成一个集合</li>
</ul>
<h2 id="第六章-图"><a class="markdownIt-Anchor" href="#第六章-图"></a> 第六章 图</h2>
<h3 id="61-图的基本概念"><a class="markdownIt-Anchor" href="#61-图的基本概念"></a> 6.1 图的基本概念</h3>
<p>图 G 由顶点集 V 和边集 E 组成，记为 G=(V, E)。</p>
<ul>
<li>图不能为空，即顶点集 V 至少要有一个顶点</li>
</ul>
<p>一些图的概念，</p>
<ul>
<li>有向图，边集 E 是有向边（或称为弧）的集合
<ul>
<li>E 可记为 E = {&lt;1,2&gt;, &lt;2,1&gt;, &lt;2,3&gt;}</li>
</ul>
</li>
<li>无向图
<ul>
<li>E 可记为 E = {(1,2), (1,3), (1,4), (2,3)}</li>
</ul>
</li>
<li><strong>简单图</strong>，两顶点间没有重复边、一个顶点出发的边不会指向自己
<ul>
<li>多重图，存在重复边、允许边的两端指向同一顶点</li>
<li>默认都是简单图</li>
</ul>
</li>
<li>完全图（简单完全图），所有顶点相互邻接
<ul>
<li>换句话说，完全图不能再添加更多的边</li>
</ul>
</li>
<li>子图，顶点集 V 和边集 E 均是另一张图的子集
<ul>
<li>生成子图，顶点集相等但边集是子集</li>
<li>允许无向图生成有向的子图</li>
</ul>
</li>
<li>连通图，<strong>无向图</strong>中任意两个顶点都是连通的
<ul>
<li>连通，两个顶点间存在路径。不需要相互直接邻接</li>
<li>连通分量，一张无向图中<strong>极大</strong>的连通子图。意义是这张无向图由这些连通图构成</li>
</ul>
</li>
<li>强连通图，<strong>有向图</strong>中任意两个顶点都是强连通的
<ul>
<li>强连通，两个顶点间存在路径，互相可到达</li>
<li>强连通分量，一张无向图中<strong>极大</strong>的强连通子图</li>
</ul>
</li>
</ul>
<p>其他相关概念，</p>
<ul>
<li>生成树，一种连通图，是包含了原连通图全部顶点的极小连通子图
<ul>
<li>去掉生成树的任意一条边，就会变成非连通图。也就是说刚好各个顶点相互连通</li>
<li><em>与连通分量的极大连通子图相区分</em></li>
</ul>
</li>
<li>生成森林，对于非连通图，它的各个连通分量对应的生成树</li>
<li>度，依附于顶点的边数
<ul>
<li>入度、出度，有向边当中的概念</li>
</ul>
</li>
<li>权，边可以标注上权值
<ul>
<li><strong>带权网</strong>，简称为<strong>网</strong></li>
</ul>
</li>
<li>稠密图、稀疏图，一般当 |E| &lt; |V| log|V| 时可视为稀疏图</li>
<li>简单路径，途径结点不重复出现</li>
<li>简单回路，除起点和终点外，途径结点不重复出现</li>
<li>距离，两顶点间的最短路径长度。不存在路径则距离为无穷 ∞</li>
<li>有向树，一个顶点的入度为 0（根结点）而其他顶点的入度都为 1</li>
</ul>
<h3 id="62-图的存储及基本操作"><a class="markdownIt-Anchor" href="#62-图的存储及基本操作"></a> 6.2 图的存储及基本操作</h3>
<p>图的存储方法，</p>
<ul>
<li>邻接矩阵法，边信息用二维数组存储
<ul>
<li>邻接矩阵，像是 <code>A[i][j] = 1</code> 就说明两顶点间存在边</li>
<li>用一维数组存储顶点信息。可省略，因为被隐含在邻接矩阵</li>
<li>性质，
<ul>
<li>设图 G 的邻接矩阵为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 存储两顶点间长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的路径数目</li>
</ul>
</li>
</ul>
</li>
<li>邻接表法，对每个顶点建立一个单链表，单链表存储一个顶点
<ul>
<li>顶点用一维数组存储</li>
<li>避免了邻接矩阵法对稀疏图的空间浪费</li>
</ul>
</li>
</ul>
<p>在邻接表基础上增强，</p>
<ul>
<li>十字链表，针对有向图。弧单链表存储更多的弧信息
<ul>
<li>弧结点有 5 个域：
<ul>
<li><code>headvex</code> <code>tailvex</code>，指向弧头和弧尾（头指向尾）</li>
<li><code>hlink</code> <code>tlink</code>，指向弧头/弧尾相同的下一条弧
<ul>
<li>也就是说，弧结点还会根据弧头和弧尾<strong>自成两条单链表</strong></li>
</ul>
</li>
<li><code>info</code>，弧的相关信息</li>
</ul>
</li>
<li>顶点结点用一维数组存储，其内容额外多出俩指针：
<ul>
<li><code>firstin</code> <code>firstout</code>，指向以该顶点为弧头或弧尾的第一个弧结点</li>
</ul>
</li>
<li>十字链表的优点是，容易求得顶点的入度和出度</li>
</ul>
</li>
<li>邻接多重表，针对无向图。边单链表存储更多的边信息
<ul>
<li>边结点结构：
<ul>
<li><code>mark</code>，标志域，标记该边是否被搜索过</li>
<li><code>ivex</code> <code>jvex</code>，该边两端顶点的下标</li>
<li><code>ilink</code> <code>jlink</code>，指向下一条端点是 <code>ivex</code> <code>jvex</code> 的边
<ul>
<li>也就是说，边结点还会根据两端顶点<strong>自成两条单链表</strong></li>
</ul>
</li>
<li><code>info</code>，边的相关信息</li>
</ul>
</li>
<li>顶点结点用一维数组存储
<ul>
<li><code>firstedge</code>，指向一个边结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>图的基本操作，</p>
<ul>
<li><code>Adjacent(G, x, y)</code>，判断是否存在弧 <code>&lt;x, y&gt;</code> 或边 <code>(x, y)</code></li>
<li><code>Neighbors(G, x)</code>，列出与 <code>x</code> 邻接的结点</li>
<li><code>InsertVertex(G, x)</code>，额外添加顶点 <code>x</code></li>
<li><code>DeleteVertex(G, x)</code>，删除顶点 <code>x</code></li>
<li><code>AddEdge(G, x, y)</code>，添加边</li>
<li><code>RemoveEdge(G, x, y)</code>，删除边</li>
<li><code>FirstNeighbor(G, x)</code>，顶点 <code>x</code> 的第一个邻接点。若不存在邻接点或 <code>x</code> 不存在，返回 -1</li>
<li><code>NextNeighbor(G, x, y)</code>，返回 <code>y</code> 之后 <code>x</code> 的下一个邻接点。若 <code>y</code> 是最后一个邻接点，返回 -1</li>
<li><code>Get_edge_value(G, x, y)</code>，获取边的权值</li>
<li><code>Set_edge_value(G, x, y)</code>，设置边的权值</li>
</ul>
<h3 id="63-图的遍历"><a class="markdownIt-Anchor" href="#63-图的遍历"></a> 6.3 图的遍历</h3>
<p>主要有两种算法，</p>
<ul>
<li>广度优先搜索（Breadth-First-Search，BFS），类似于二叉树的层次遍历算法
<ul>
<li>同样需要一个队列。额外需要一个数组标记顶点是否被访问过</li>
<li>时间复杂度：
<ul>
<li>邻接表存储时，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|+|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>
<ul>
<li>每个顶点被访问一次，每个顶点的单链表被访问一次</li>
</ul>
</li>
<li>邻接矩阵存储时，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>广度优先生成树，遍历过程中获得的遍历树</li>
</ul>
</li>
<li>深度优先搜索（Depth-First-Search，DFS），类似于树的先序遍历
<ul>
<li>使用递归会让过程很简洁。额外需要一个数组标记顶点是否被访问过</li>
<li>深度优先生成树，要注意保证结点只能访问一次</li>
</ul>
</li>
</ul>
<p>图的遍历算法可以判断图的连通性。</p>
<ul>
<li>连通性：
<ul>
<li>对无向图来说，从任一结点出发，仅需一次遍历就能访问所有结点</li>
<li>对有向图来说，某结点到图中每个顶点都有路径
<ul>
<li>注意，若是非强连通图，仍然会存在结点无法到达某个结点的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="64-图的应用"><a class="markdownIt-Anchor" href="#64-图的应用"></a> 6.4 图的应用</h3>
<p>最小生成树，带权连通图中，权值之和最小的生成树。</p>
<ul>
<li><strong>记忆：最小生成树就是能长出的最小的树木</strong></li>
<li>对应的图的边数为顶点数减 1</li>
</ul>
<p>最小生成树的算法，</p>
<ul>
<li>Prim（普里姆）算法，从某个顶点开始取权值最小的边
<ul>
<li>选取边之后，下一次选取要考虑所有能到达的顶点</li>
<li>适于边稠密的图</li>
</ul>
</li>
<li>Kruskal（克鲁斯卡尔）算法，依次取权值最小的边
<ul>
<li>注意要避免构成回路</li>
<li>适于边稀疏的图</li>
</ul>
</li>
</ul>
<p>最短路径，带权图两顶点间的最短路径。</p>
<ul>
<li>Dijkstra 算法，求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到其他点的最短距离
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，即使是只想知道一条最短路径</li>
<li>变量：
<ul>
<li>数组 <code>inS</code>，记录 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是否被经过</li>
<li>数组 <code>dist[]</code>，记录目前的最短路径长度</li>
<li>数组 <code>path[]</code>，记录目前的最短路径上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前驱结点</li>
</ul>
</li>
<li>具体过程：
<ul>
<li>初始化 <code>inS</code>，除了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 true 外其余都为 false</li>
<li>初始化 <code>dist[]</code>，对于原点直接可达的顶点，填边的权重，其余填 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">∞</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></li>
<li>初始化 <code>path[]</code>，对于原点直接可达的顶点填原点，其余填 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></li>
<li>从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 出发：
<ul>
<li><strong>选择 <code>dist[i]</code> 最小的结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong></li>
<li>检查 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 能到达的其他结点，对比 <code>dist[]</code> 看是能借助 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 达成更短距离</li>
<li>若有，就更新 <code>dist[]</code>，并更新 <code>path[]</code> 对应位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>将 <code>inS[i]</code> 置于 true</li>
<li>不断重复，直到不能找到下一个结点</li>
</ul>
</li>
</ul>
</li>
<li>注意，边的权值为负时不适用</li>
<li>注意，获得最短路径的顺序，与最短路径长度的排序有关：必须从最短到最长</li>
</ul>
</li>
<li>Floyd 算法
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，与调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span></span></span></span> 次 Dijkstra 算法有相同时间复杂度</li>
<li>主要内容：
<ul>
<li>邻接矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>，存储有向图。<code>A[i][j]</code> 存储从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的路径长度</li>
</ul>
</li>
<li>具体过程：
<ul>
<li>初始的邻接矩阵为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，记录了各个结点间能直接可达的路径长度（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">∞</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> 代表不可达）</li>
<li>从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 开始，计算 $A_k[i][j]=min{d_{k-1}[i][j], d_{k-1}[i][k]+d_{k-1}[k][j]} $
<ul>
<li>例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时，对矩阵每个元素所在的行与列第 2 个元素的和，与原值相比较</li>
<li>计算结果的意义是，用顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作为中间结点后的最短路径</li>
<li>每次发生矩阵元素变动，也说明对应的 <code>path[]</code> 改变</li>
</ul>
</li>
</ul>
</li>
<li>允许边的权值为负数，但不允许包含负权值的边组成回路</li>
</ul>
</li>
</ul>
<p>有向无环图（DAG 图）的描述表达式，</p>
<ul>
<li>对于某个算式，可用二叉树表示。但为了充分利用结点，可用有向无环图表示</li>
</ul>
<p>拓扑排序相关，</p>
<ul>
<li>AOV 网，在<strong>有向图</strong>中，用<strong>顶点表示活动</strong>，用有向边表示活动的依赖关系
<ul>
<li>就是用 DAG 图表示工程的活动先后关系</li>
</ul>
</li>
<li>拓扑排序，一种针对有向无环图的结点的排序方式
<ul>
<li>其特点：
<ul>
<li>每个顶点只出现一次</li>
<li>若在排序结果中，顶点 A 在顶点 B 的前面，则不存在从 B 到 A 的路径</li>
<li><strong>一个 AOV 网可能有多种拓扑排序序列</strong></li>
</ul>
</li>
<li>常用的获取步骤：
<ul>
<li>从 AOV 网中选择一个没有前驱的顶点（入度为 0），并输出</li>
<li>删除该顶点及相关联的边</li>
<li>重复以上步骤。若最终无法输出所有顶点，则说明图中有环</li>
<li>若有多个入度为 0 的的结点，需要都执行一遍</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>关键路径相关，</p>
<ul>
<li>AOE 网，在带权有向图中，用顶点表示事件，用<strong>有向边表示活动</strong>，用权表示开销
<ul>
<li>只有一个入度为 0 的结点，称为源点</li>
<li>只有一个出度为 0 的结点，称为汇点</li>
<li>关键路径，从源点到汇点的所有路径中，路径长度最大的路径
<ul>
<li>关键路径是工程的时间上限。另一个说法是，完成工程的最短时间就是关键路径的长度</li>
<li>这样想：所有活动都要完成，活动可以并行进行。所以关键路径是最短时间</li>
</ul>
</li>
<li>关键活动，关键路径上的活动</li>
</ul>
</li>
<li>关键路径的计算，
<ul>
<li>几个变量：
<ul>
<li><code>earliest[i]</code>，从源点到结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的最长路径长度，即事件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 可能的最早发生时间
<ul>
<li>初始时均为 0，之后从源点到汇点依次求得</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">{</mo><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathrm{earliest}[i]=\mathrm{max}\{\mathrm{earliest}(j)+w(i,j)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">{</span><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的直接前驱结点</li>
</ul>
</li>
<li><code>latest[i]</code>，从源点到结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的最长路径长度，即事件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 可能的最迟发生时间
<ul>
<li>初始时 <code>latest[汇点]</code> 等于 <code>earliest[汇点]</code>，然后从汇点到源点反着求</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">{</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>w</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathrm{latest}[i]=\mathrm{min}\{\mathrm{latest}(j)-w(i,j)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span><span class="mopen">{</span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的直接后继结点</li>
</ul>
</li>
</ul>
</li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathrm{earliest}[i]=\mathrm{latest}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">e</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">l</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 为关键活动</li>
</ul>
</li>
</ul>
<h2 id="第七章-查找"><a class="markdownIt-Anchor" href="#第七章-查找"></a> 第七章 查找</h2>
<p>重点在平均查找长度 ASL 的计算、各个算法的特点及性能。</p>
<p>注意平均查找长度是计算的比较次数，散列表时计算不成功的话与空对比也算比较次数。</p>
<h3 id="71-查找的基本概念"><a class="markdownIt-Anchor" href="#71-查找的基本概念"></a> 7.1 查找的基本概念</h3>
<p>查找，数据集合中查找特定条件的数据元素。其结果有查找成功和查找失败。</p>
<ul>
<li>查找表（查找结构），被查的数据集合</li>
<li>静态查找表，不能进行增删操作的查找表。与之相对的是动态查找表</li>
<li>关键字，有点像数据库中的候选码</li>
<li>平均查找长度，一次查找需要比较关键词的次数
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">ASL=\Sigma^n_{i=1}P_iC_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.941994em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是查找表长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是各数据元素的查找概率（一般为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是这数据元素的比较次数</li>
</ul>
</li>
</ul>
<h3 id="72-顺序查找和折半查找"><a class="markdownIt-Anchor" href="#72-顺序查找和折半查找"></a> 7.2 顺序查找和折半查找</h3>
<p>顺序查找，又称线性查找。</p>
<ul>
<li>编写代码时引入了 “哨兵”，避免了额外的判断语句<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType *elem;                         <span class="comment">// 0 号元素留空，用来放哨兵</span></span><br><span class="line">  <span class="type">int</span> TableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, ElemType key)</span>&#123; <span class="comment">// key 是查找项，也被用作哨兵</span></span><br><span class="line">  ST.elem[<span class="number">0</span>] = key;                       <span class="comment">// 写入哨兵</span></span><br><span class="line">  <span class="keyword">for</span>(i=ST.TableLen;ST.elem[i]!=key;--i); <span class="comment">// 从后往前找，到 0 号元素必定跳出</span></span><br><span class="line">  <span class="keyword">return</span>  i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>对于数字有序表，可以提前得知查找失败，不必查找所有的数据</li>
</ul>
<p>折半查找，又称二分查找，仅适用于有序的顺序表。若是链式存储结构则不适用。</p>
<ul>
<li>二叉判定树，描述搜索的过程
<ul>
<li>圆形结点代表元素，方形结点代表失败</li>
</ul>
</li>
<li>代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span>&#123;</span><br><span class="line">  <span class="type">int</span> low=<span class="number">0</span>, high=L.TableLen<span class="number">-1</span>, mid;</span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">      mid=(low&lt;=high/<span class="number">2</span>)       <span class="comment">// 取中间位置</span></span><br><span class="line">      <span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line">          <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">          high=mid<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          low=mid+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>注意：向上向下取整并没有严格规定，但必须保证在同一次查找中使用相同的规则</li>
</ul>
<p>分块查找，又称索引顺序查找。块内顺序查找，块间折半查找或顺序查找，可加快速度。</p>
<ul>
<li>分块，块内可以无序，块间必须有序。例如第一个块所有关键字都小于第二个块的关键字</li>
<li>索引表，存储每个块的最大关键字及其下标</li>
<li>进行搜索时，首先根据索引表确定要搜索的块，再在块中顺序查找</li>
</ul>
<h3 id="73-搜索树"><a class="markdownIt-Anchor" href="#73-搜索树"></a> 7.3 搜索树</h3>
<p>二叉排序树，左子树所有结点的值都小于右子树所有结点的值，根结点的值处在两者之间。</p>
<ul>
<li>对二叉排序树进行中序遍历，可以得到一个递增序列</li>
<li>二叉排序树在删除结点时，要检查子树是否有结点能代替被删除结点
<ul>
<li>搜索中序遍历的直接后继</li>
</ul>
</li>
</ul>
<p>平衡二叉树 AVL，左右子树的深度之差不超过 1。</p>
<ul>
<li>平衡二叉树的调整方法
<ul>
<li>新元素插入在左（右）孩子的左（右）子树：单旋转，第二层来到第一层，相互交换</li>
<li>新元素插入在左（右）孩子的右（左）子树：双旋转，第三层向第一层突破
<ul>
<li>第三层的左右子树被赋予为第一层结点和第二层结点</li>
</ul>
</li>
<li>若是元素删除，则从检查不平衡子树，转换为新元素插入的情况</li>
</ul>
</li>
<li>平衡二叉树的平均查找长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>红黑树，优化 AVL 树，避免频繁调整全树拓扑。</p>
<ul>
<li>术语
<ul>
<li>黑高，结点到一个叶节点途径的黑结点数量
<ul>
<li>红黑树的黑高，是根节点的黑高</li>
</ul>
</li>
</ul>
</li>
<li>基本特点：
<ul>
<li>根节点和叶结点都是黑色的。叶结点是虚构的 NULL 结点</li>
<li>不存在两个相邻的红结点（即红结点的父结点和孩子结点都是黑色）</li>
<li><strong>一个结点，到任一叶节点的简单路径上，黑结点的数量相同</strong></li>
</ul>
</li>
<li>结论：
<ul>
<li>根节点，到叶节点的最长路径不大于最短路径的 2 倍</li>
</ul>
</li>
<li>红黑树的插入
<ul>
<li>插入结点初始为红色</li>
<li>若插入的是根节点则变黑色直接插入，若父结点是黑色则直接插入</li>
<li>父结点是红色，就要分两种情况：
<ul>
<li>父结点的父结点，的另一个孩子为叶节点（NULL）
<ul>
<li>与平衡二叉树相同，（无视叶节点）把三层变为二层</li>
</ul>
</li>
<li>父结点的父结点，的另一个孩子不是叶节点
<ul>
<li>将那个另一个孩子变为黑色，父结点的父结点变为红色，父结点变为黑色</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>红黑树的删除
<ul>
<li>被删结点与直接中序后继结点，一个红一个黑（包括 NULL 叶节点）
<ul>
<li>用直接中序后继结点填补，填补后为黑色</li>
</ul>
</li>
<li>被删结点与直接中序后继结点，两个都为黑（包括 NULL 叶节点）
<ul>
<li>用直接中序后继结点填补，填补后标记为<strong>双黑结点</strong></li>
<li>检查兄弟结点（父结点的另一个孩子），
<ul>
<li>兄弟结点为黑色
<ul>
<li>选择兄弟结点的一个红色孩子，并将兄弟结点设置为父结点颜色
<ul>
<li>若兄弟与选择的红孩子在同一边，红孩子变黑
<ul>
<li>兄弟结点旋转为父结点，双黑变回单黑结点，父结点为红则变黑</li>
</ul>
</li>
<li>若兄弟与选择的红孩子异边，红孩子变黑，孩子结点旋转与兄弟换层
<ul>
<li>新的兄弟结点旋转为父结点，双黑变回单黑结点，父结点为红则变黑</li>
</ul>
</li>
</ul>
</li>
<li>假如兄弟的全部孩子都是黑色，就递归处理
<ul>
<li>双黑结点的父结点为黑色，就双黑变单黑，父结点变双黑</li>
<li>直到父结点为红色，此时父结点仅变单黑，原双黑变单黑（双 + 红 = 单）</li>
</ul>
</li>
</ul>
</li>
<li>兄弟结点为红色。思路是转换到兄弟为黑色的情况
<ul>
<li>兄弟变黑，父结点变红，然后兄弟与父结点通过旋转交换层次</li>
<li>然后，再次检查双黑结点的兄弟，又分为了黑色和红色的情况</li>
</ul>
</li>
</ul>
</li>
<li>特殊情况：根节点为双黑。则直接双变单，整体黑高减 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="74-b-树和-b-树"><a class="markdownIt-Anchor" href="#74-b-树和-b-树"></a> 7.4 B 树和 B+ 树</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 阶 B 树是一棵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 叉搜索树。其内容有序。</p>
<ul>
<li>根节点至少有两个孩子，结点内最多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素，<strong>所有失败结点均在同一层上</strong></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 体现在，一个结点最大能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 个孩子</li>
<li>除根节点和失败结点外，每个结点<strong>至少有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">m/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord">2</span></span></span></span> - 1 个元素，向上取整</strong></li>
</ul>
<p>B 树的相关内容，</p>
<ul>
<li>B 树的高度，不计失败结点</li>
<li>B 树的插入，若元素数量超出上限，需要进行分裂
<ul>
<li>将超标结点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">m/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 处元素（向上取整）上移到父结点，剩下两部分分裂</li>
</ul>
</li>
<li>B 树的删除，分情况
<ul>
<li>被删除元素在叶节点上：
<ul>
<li>直接删除。若出现下溢（元素数量过少），则先左后右，检查兄弟结点是否有多余元素</li>
<li>若有多余元素，就把一个元素移到父结点，父结点一个元素补上叶节点</li>
<li>若没有多余元素，则先左后右的顺序合并结点，顺便从父结点拿一个元素</li>
</ul>
</li>
<li>被删元素不在叶节点上：
<ul>
<li>将右子树的最小元素拿出来，补回去。这就转换为了删除叶节点元素的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>B + 树，B 树的变体。</p>
<ul>
<li>父结点就像是孩子们的指针，父结点存储各个孩子最大的一个元素
<ul>
<li>这样一来，结点元素数量 = 孩子数量</li>
</ul>
</li>
<li>叶子结点包含了全部元素，并类似链表相连。所以 B + 树的搜索也能使用顺序方法</li>
</ul>
<h3 id="75-散列表"><a class="markdownIt-Anchor" href="#75-散列表"></a> 7.5 散列表</h3>
<p>散列表，根据关键字能直接访问的数据结构。<code>key</code> 和 <code>value</code>。</p>
<ul>
<li>散列函数，使得关键字映射为地址的函数</li>
<li>常用的散列函数：
<ul>
<li>直接定址法，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">H(key)=key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>×</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">H(key)=a×key+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 都为常数</li>
<li>除留余数法，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi mathvariant="normal">%</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">H(key)=key\%p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94444em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">%</span><span class="mord mathnormal">p</span></span></span></span>，即取余数</li>
<li>数字分析法，若关键字是纯数字，就分析各位取值概率，然后选出均匀合适的散列函数</li>
<li>平方取中法，取关键字的平方值的中间几位，作为散列地址</li>
</ul>
</li>
</ul>
<p>冲突，使用散列函数不可避免冲突。</p>
<ul>
<li>开放定位法，按照某种规则，将冲突元素放入到探查过程中<strong>首次发现</strong>的空位置
<ul>
<li>线性探测法，直接按照次序往后找空位置</li>
<li>平方探测法，二次探测法，寻找相对位置在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>3</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1^2,-1^2,2^2,-2^2,3^2,-3^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>…… 的下一个位置
<ul>
<li>可以避免 “堆积问题”，单不能探测到散列表上的所有单元</li>
</ul>
</li>
<li>双散列法，使用两个散列函数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>×</mo><msub><mi>H</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">H_i(key)=(H_1(key)+i×H_2(key))\%m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 是冲突次数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是散列表长度</li>
</ul>
</li>
</ul>
</li>
<li>拉链法，此时的散列表为各个单链表的头指针，发生冲突直接入队即可
<ul>
<li>避免非同义词冲突</li>
</ul>
</li>
</ul>
<p>概念，</p>
<ul>
<li>装填因子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">α</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>，一个表的装满程度
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mrow><mtext>表中记录</mtext><mi>n</mi></mrow><mrow><mtext>散列表长度</mtext><mi>m</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">α=\frac{表中记录 n}{散列表长度 m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">散</span><span class="mord cjk_fallback mtight">列</span><span class="mord cjk_fallback mtight">表</span><span class="mord cjk_fallback mtight">长</span><span class="mord cjk_fallback mtight">度</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">表</span><span class="mord cjk_fallback mtight">中</span><span class="mord cjk_fallback mtight">记</span><span class="mord cjk_fallback mtight">录</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
<li>平均查找长度 ASL，用比较次数衡量
<ul>
<li>对空数据也计一次比较</li>
</ul>
</li>
</ul>
<h2 id="第八章-排序"><a class="markdownIt-Anchor" href="#第八章-排序"></a> 第八章 排序</h2>
<h3 id="81-排序的基本概念"><a class="markdownIt-Anchor" href="#81-排序的基本概念"></a> 8.1 排序的基本概念</h3>
<p>主要注意：</p>
<ul>
<li>稳定、不稳定</li>
<li>内部排序（元素放在内存）、外部排序（元素无法全部放内存）</li>
<li>对序列进行排序，至少需要比较 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log_2(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span> 次比较，向上取整</li>
</ul>
<h3 id="82-插入排序"><a class="markdownIt-Anchor" href="#82-插入排序"></a> 8.2 插入排序</h3>
<p>插入排序，思路是从左到右遍历序列，插入到左边已经排序好的子序列。</p>
<ul>
<li>代码实现思路（从小到达排序）：
<ul>
<li>从第二个元素开始。寻找这个元素在左侧子串的插入位置</li>
<li>若要插入，则部分元素往后挪一格</li>
</ul>
</li>
<li>使用到了哨兵，即数组第一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 用来临时存储</li>
<li>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，算法是稳定的</li>
<li>适用于顺序存储表，还能支持链式存储的线性表。排序算法大都只能用于顺序存储表</li>
</ul>
<p>折半插入排序，插入排序的改进。在查找插入位置时，使用折半查找。</p>
<ul>
<li>时间复杂度同样是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，单能减少元素比较次数。算法是稳定的</li>
</ul>
<p>希尔排序，又称缩小增量排序。思路是按照某个“增量”对元素分组，分组各自排序，再全体排序。</p>
<ul>
<li>若增量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>，则下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mi>d</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>2</mn><mi>d</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>3</mn><mi>d</mi><mo>…</mo></mrow><annotation encoding="application/x-tex">i,i+d,i+2d,i+3d…</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> 的元素为一组，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 为非负整数
<ul>
<li>意思是，分隔一段距离取一个元素</li>
</ul>
</li>
<li>代码实现内容：
<ul>
<li>取增量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">d_1=\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（元素数量的一半）</li>
<li>对间隔 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的所有元素进行插入排序</li>
<li>令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>=</mo><mfrac><msub><mi>d</mi><mn>1</mn></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">d_2=\frac{d_1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2412079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，继续排序。直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">d_t=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，此时排序完成便得到有序数组</li>
</ul>
</li>
<li>平均时间复杂度约为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，最差为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。算法是不稳定的</li>
</ul>
<h3 id="83-交换排序"><a class="markdownIt-Anchor" href="#83-交换排序"></a> 8.3 交换排序</h3>
<p>冒泡排序，经典的交换排序。思路是不断两两比较相邻元素的值，进行交换。</p>
<ul>
<li>从后往前（或从前往后）两两比较并交换，至多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 趟就能排好序</li>
<li>下一趟排序可以跳过上一趟末尾的那个元素。若某一趟没有发生交换，则可提前终止算法</li>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，稳定</li>
</ul>
<p>快速排序，不稳定的排序方法。</p>
<ul>
<li>需要几个指针：<code>low</code> <code>high</code> <code>i</code> <code>j</code>
<ul>
<li><code>low</code> <code>high</code> 为当前子串下标的上下限，<code>i</code> 只能右移 <code>j</code> 只能左移</li>
</ul>
</li>
<li>具体过程（从小到大排列）：
<ul>
<li>初始时 <code>i</code> = <code>low</code>，<code>j</code> = <code>high</code> + 1</li>
<li>循环：
<ul>
<li>下标 <code>i</code> 逐步前进（右移），当 <code>D[i]</code> ≥ <code>D[low]</code> 时停止前进</li>
<li>下标 <code>j</code> 逐步后退（左移），当 <code>D[j]</code> ≤ <code>D[low]</code> 时停止后退</li>
<li>若 <code>i</code> &lt; <code>j</code>，则交换 <code>D[i]</code> <code>D[j]</code>；否则交换 <code>D[low]</code> <code>D[j]</code>，并退出循环</li>
</ul>
</li>
<li>此时 <code>D[j]</code> 元素必定归位。左右两边子串分别再次进行以上的步骤</li>
</ul>
</li>
<li>趟，似乎这里的趟要理解为层次。例如分成两个子串，都进行了排序才算一趟
<ul>
<li>于是，一趟能定下的归位元素可能不只 1 个</li>
</ul>
</li>
<li>平均时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，不稳定</li>
</ul>
<h3 id="84-选择排序"><a class="markdownIt-Anchor" href="#84-选择排序"></a> 8.4 选择排序</h3>
<p>简单选择排序，每一趟寻找关键字最小的元素，与第一个元素交换位置。</p>
<ul>
<li>每一趟都能确定一个元素位置</li>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。<strong>不稳定</strong>，因为会随机交换位置</li>
</ul>
<p>堆排序，使用堆进行排序。</p>
<ul>
<li>堆，一种完全二叉树。用数组以行优先方式存储
<ul>
<li>最大堆，双亲元素总大于孩子元素。此时，堆顶为最大值</li>
</ul>
</li>
<li>堆排序的过程：构建最大堆、取出堆顶并调整堆
<ul>
<li>构建最大堆
<ul>
<li>下标从 <code>n/2</code> 开始到 <code>0</code>，以这些结点为根进行调整</li>
</ul>
</li>
<li>取出堆顶</li>
<li>调整堆
<ul>
<li>将数组末尾的元素放置在堆顶</li>
<li>从根结点开始，寻找较大孩子，进行向下调整。比起构建最大堆，此时只需要一轮调整</li>
</ul>
</li>
</ul>
</li>
<li>堆也支持元素插入。将新元素放在末尾后进行排序</li>
<li>算法适于元素极多的情况</li>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，不稳定</li>
</ul>
<h3 id="85-归并排序"><a class="markdownIt-Anchor" href="#85-归并排序"></a> 8.5 归并排序</h3>
<p>归并排序，例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 路归并排序，将排序表的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个记录视为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个有序子表，每轮 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个表合并合并。</p>
<ul>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，稳定</li>
</ul>
<p>基数排序，基于关键字各个位的大小进行排序。也就是说，根据多关键字进行排序。</p>
<ul>
<li>最主关键字，最次关键字</li>
<li>有两种方法：最高位优先法，<strong>最低位优先法</strong></li>
<li>若要对数组排序，需要用最低位优先法。就是从个位开始排序</li>
<li>具体过程：
<ul>
<li>根据个位数组进行分组并排序，之后是十位，百位……</li>
</ul>
</li>
<li>稳定</li>
</ul>
<h3 id="86-各种内部排序算法的比较"><a class="markdownIt-Anchor" href="#86-各种内部排序算法的比较"></a> 8.6 各种内部排序算法的比较</h3>
<p>时间复杂度上看，</p>
<ul>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 有：
<ul>
<li>简单选择排序、直接插入排序、冒泡排序</li>
</ul>
</li>
<li>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 有：
<ul>
<li>堆排序、快速排序、归并排序</li>
</ul>
</li>
</ul>
<p>空间复杂度上看，</p>
<ul>
<li>常数个辅助空间：
<ul>
<li>简单选择排序、插入排序、冒泡排序、希尔排序、堆排序</li>
</ul>
</li>
<li>快速排序平均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，2 路归并排序为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>稳定性上看，</p>
<ul>
<li>简单选择排序、快速排序、希尔排序、堆排序，都不稳定</li>
<li>时间复杂度在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 且稳定的，只有归并</li>
</ul>
<h3 id="87-外部排序"><a class="markdownIt-Anchor" href="#87-外部排序"></a> 8.7 外部排序</h3>
<p>外部排序，因文件过大而不完全在内存中进行排序。内存与外存交换。</p>
<p>外部排序通常使用归并排序法。增加归并路数能减少 I/O 次数，提高排序效率。</p>
<p>败者树，一种完全二叉树，避免归并路数过大而导致合并成本过高。</p>
<ul>
<li>叶结点存储的是归并段，双亲结点存储孩子的败者（较小的那个）。根结点是最小和第二小</li>
</ul>
<p>置换选择算法，在生成初始归并段时避免段数过多。</p>
<ul>
<li>选择一个确定大小的工作区，从输入文件中抓取元素装满工作区。然后，选择工作区中最小的元素，放到输出文件区中，并从输入文件抓取一个元素重新装满工作区。接下来就从工作区寻找刚好比输出文件区所有元素更大的元素并移入输出文件区，直到工作区中不能找到满足条件的元素。此时输出文件区中的元素被视为一个初始归并段</li>
</ul>
<p>最佳合并树，对置换选择算法得到的长度不等的初始对并段进行排序。</p>
<ul>
<li>构建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 叉哈夫曼树。不足的叶节点用 0 顶替</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">HiDolen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/[object%20Object]/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">http://example.com/[object%20Object]/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">时间·线</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">课堂笔记</a><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94/">考研</a><a class="post-meta__tags" href="/tags/408/">408</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86C/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86C/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">通信原理C</div></div></a></div><div class="next-post pull-right"><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">操作系统</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">计算机网络</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">计算机组成原理</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" title="概率论与数理统计"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">概率论与数理统计</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="线性代数"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">线性代数</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/%E6%95%B0%E5%AD%A6/%E9%AB%98%E6%95%B0/%E4%B8%80%E4%BA%9B%E5%85%AC%E5%BC%8F/" title="一些公式"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">一些公式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HiDolen</div><div class="author-info__description">HiDolen 的个人博客。平时写的笔记都在这里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">110</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text"> 第一章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1 数据结构的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2 算法和算法评价</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text"> 第二章 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1 线性表的定义、基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2 线性表的顺序表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3 线性表的链式表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88-%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text"> 第三章 栈、队列和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%A0%88stack"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1 栈（Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E9%98%9F%E5%88%97queue"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 队列（Queue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3 栈和队列的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E6%95%B0%E7%BB%84%E5%92%8C%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4 数组和特殊矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text"> 第四章 串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1 串的定义和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2 串的模式匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text"> 第五章 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2 二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3 二叉树的遍历和线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E6%A0%91-%E6%A3%AE%E6%9E%97"><span class="toc-number">5.4.</span> <span class="toc-text"> 5.4 树、森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%93%88%E5%A4%AB%E6%9B%BC"><span class="toc-number">5.5.</span> <span class="toc-text"> 5.6 树与二叉树的应用（哈夫曼）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text"> 第六章 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text"> 6.1 图的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.</span> <span class="toc-text"> 6.2 图的存储及基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.</span> <span class="toc-text"> 6.3 图的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text"> 6.4 图的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="toc-number">7.</span> <span class="toc-text"> 第七章 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text"> 7.1 查找的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">7.2.</span> <span class="toc-text"> 7.2 顺序查找和折半查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">7.3.</span> <span class="toc-text"> 7.3 搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-b-%E6%A0%91%E5%92%8C-b-%E6%A0%91"><span class="toc-number">7.4.</span> <span class="toc-text"> 7.4 B 树和 B+ 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">7.5.</span> <span class="toc-text"> 7.5 散列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text"> 第八章 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#81-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text"> 8.1 排序的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text"> 8.2 插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.</span> <span class="toc-text"> 8.3 交换排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.4.</span> <span class="toc-text"> 8.4 选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">8.5.</span> <span class="toc-text"> 8.5 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86-%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.6.</span> <span class="toc-text"> 8.6 各种内部排序算法的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">8.7.</span> <span class="toc-text"> 8.7 外部排序</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By HiDolen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>