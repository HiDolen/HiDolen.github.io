<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统 | 时间·线</title><meta name="keywords" content="课堂笔记,考研,408"><meta name="author" content="HiDolen"><meta name="copyright" content="HiDolen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 计算机系统概述  1.1 操作系统的基本概念 计算机系统自下而上大致分为：硬件、操作系统、应用程序、应用程序和用户。 操作系统，是计算机系统中最基本的系统软件。 操作系统的特征，  并发，多个事件在同一时间间隔内发生  操作系统的并发性是通过分时得以实现的 并发与并行：并行是指具有同时运行的能力，需要有硬件支持  单处理机下，进程与进程不能并行，但可以并发     共享，指资源共享  互">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/[object%20Object]/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="时间·线">
<meta property="og:description" content="第一章 计算机系统概述  1.1 操作系统的基本概念 计算机系统自下而上大致分为：硬件、操作系统、应用程序、应用程序和用户。 操作系统，是计算机系统中最基本的系统软件。 操作系统的特征，  并发，多个事件在同一时间间隔内发生  操作系统的并发性是通过分时得以实现的 并发与并行：并行是指具有同时运行的能力，需要有硬件支持  单处理机下，进程与进程不能并行，但可以并发     共享，指资源共享  互">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-09-08T06:36:17.000Z">
<meta property="article:modified_time" content="2022-09-08T06:42:40.674Z">
<meta property="article:author" content="HiDolen">
<meta property="article:tag" content="课堂笔记">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/[object%20Object]/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-08 14:42:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">110</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">时间·线</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-08T06:36:17.000Z" title="发表于 2022-09-08 14:36:17">2022-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-08T06:42:40.674Z" title="更新于 2022-09-08 14:42:40">2022-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">课堂笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/">考研</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/">408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章-计算机系统概述"><a class="markdownIt-Anchor" href="#第一章-计算机系统概述"></a> 第一章 计算机系统概述</h2>
<h3 id="11-操作系统的基本概念"><a class="markdownIt-Anchor" href="#11-操作系统的基本概念"></a> 1.1 操作系统的基本概念</h3>
<p>计算机系统自下而上大致分为：硬件、操作系统、应用程序、应用程序和用户。</p>
<p>操作系统，是计算机系统中最基本的系统软件。</p>
<p>操作系统的特征，</p>
<ul>
<li>并发，多个事件在同一<strong>时间间隔</strong>内发生
<ul>
<li>操作系统的并发性是通过分时得以实现的</li>
<li><strong>并发与并行</strong>：并行是指具有同时运行的能力，需要有硬件支持
<ul>
<li>单处理机下，进程与进程不能并行，但可以并发</li>
</ul>
</li>
</ul>
</li>
<li>共享，指资源共享
<ul>
<li><strong>互斥共享方式，不允许同时访问</strong>；同时访问方式，允许同时访问</li>
<li>临界区，进程中访问临界资源的代码</li>
<li>临界资源，仅允许同时一个进程使用的共享资源</li>
</ul>
</li>
<li>虚拟，可归纳为：时分复用技术（例如 CPU），空分复用技术（例如虚拟存储器）</li>
<li>异步，多个程序并发但不同步地执行
<ul>
<li>操作系统必须保证，只要运行环境相同，进程的多次运行能得到一样的结果</li>
</ul>
</li>
</ul>
<p>操作系统的功能，</p>
<ul>
<li>操作系统作为计算机系统<strong>资源</strong>的管理者
<ul>
<li>处理机管理。可归结为进程的管理，包括进程生命周期控制、进程的并发等</li>
<li>存储器管理。为多道程序的运行提供环境，主要包括内存分配与回收、地址映射等</li>
<li>文件管理、设备管理</li>
</ul>
</li>
<li>操作系统作为用户与计算机硬件系统之间的接口
<ul>
<li>命令接口，用户通过命令接口组织和控制作业的执行
<ul>
<li>联机命令接口，通过控制台或终端输入操作命令</li>
<li>脱机命令接口，又称批处理命令接口，适用于批处理系统</li>
</ul>
</li>
<li>程序接口，由一组系统调用（广义指令）组成，用户通过程序使用这些系统调用</li>
</ul>
</li>
</ul>
<h3 id="12-操作系统的发展"><a class="markdownIt-Anchor" href="#12-操作系统的发展"></a> 1.2 操作系统的发展</h3>
<ul>
<li>手工操作阶段
<ul>
<li>无操作系统，用户独占全机，资源利用率低</li>
</ul>
</li>
<li>批处理操作系统
<ul>
<li>系统对作业成批进行，资源利用率提高
<ul>
<li>单道批处理系统，内存只有一道作业
<ul>
<li>自动性、顺序性、单道性</li>
</ul>
</li>
<li>多道批处理系统，内存中同时存放多道相互独立的进程
<ul>
<li><strong>宏观上并行，微观上串行</strong>。程序轮流占用 CPU</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>分时操作系统
<ul>
<li>批处理系统缺点是不提供人机交互能力，用户响应时间长</li>
<li>分时技术，把处理器的运行时间分为时间片。作业轮流使用时间片</li>
<li>分时操作系统的特点：
<ul>
<li>同时性，一台计算机可连接多个终端</li>
<li>交互性，用户通过终端直接控制程序运行</li>
<li>独立性，各个终端用户互不干扰</li>
<li>及时性，用户请求能很快响应</li>
</ul>
</li>
</ul>
</li>
<li>实时操作系统
<ul>
<li><strong>在分时操作系统基础上</strong>，对紧急任务无视时间片排队</li>
<li>硬实时系统，某动作必须在限定时间内完成；软实时系统，允许偶尔的违反时间规定</li>
<li>主要特点是，及时性、可靠性</li>
</ul>
</li>
<li>网络操作系统
<ul>
<li>通过网络将计算机结合起来，实现计算机间的资源共享及通信</li>
</ul>
</li>
<li>分布式计算机系统
<ul>
<li>系统中每台计算机地位相同，任何工作都可以让多台计算机并行工作、协同完成</li>
<li>分布性、并行性</li>
</ul>
</li>
<li>个人计算机操作系统、嵌入式操作系统、服务器操作系统、智能手机操作系统等</li>
</ul>
<h3 id="13-操作系统运行环境"><a class="markdownIt-Anchor" href="#13-操作系统运行环境"></a> 1.3 操作系统运行环境</h3>
<p>CPU 的运行模式，</p>
<ul>
<li>用户态，用户程序运行在用户态
<ul>
<li>非特权指令，允许用户直接使用的指令。不能直接访问系统软硬件资源</li>
</ul>
</li>
<li>核心态，操作系统内核程序运行在核心态
<ul>
<li>特权指令，不允许用户直接使用的指令。包括 I/O 指令、置中断指令、存取受保护寄存器等</li>
<li>操作系统内核
<ul>
<li>包含时钟管理、中断处理、设备驱动等底层模块，以及进程管理、设备管理等关键内容</li>
<li>包括 4 方面的内容：
<ul>
<li>时钟管理，时钟被用来提供时间和进程的中断切换</li>
<li>中断机制，保护和恢复中断现场的信息</li>
<li>原语，按层级结构设计的操作系统，其底层是一些完成特定操作的程序，称为原语
<ul>
<li>这些程序最接近硬件，其运行不可分割<strong>不可被中断</strong>，运行时间短且调用频繁</li>
<li>像是设备驱动、CPU 切换、进行通信等都可被定义为原语，成为内核一部分</li>
</ul>
</li>
<li>系统控制的数据结构及处理，例如进程控制块（PCB）、内存分配表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>用户态和核心态的切换，通过中断或异常。</p>
<ul>
<li>状态切换是在硬件层面上被支持的</li>
<li>中断，也称外中断，如 I/O 结束中断
<ul>
<li>分为，可屏蔽中断、不可屏蔽中断</li>
</ul>
</li>
<li>异常，也称内中断
<ul>
<li>不可被屏蔽。一旦出现，应立即处理</li>
<li>分为：
<ul>
<li>故障，由指令执行引起，可以被修正。不能修复则会转换为终止</li>
<li>自陷（trap），故意引起的异常。例如程序调试时的断点</li>
<li>终止，出现致命错误，控制权转交系统。其结果往往是程序被终止</li>
</ul>
</li>
</ul>
</li>
<li>软件中断：故障异常、自陷异常</li>
<li>硬件中断：终止异常、外部中断</li>
</ul>
<p>中断和异常的处理过程，</p>
<ul>
<li>CPU 遇到中断或异常，就打断当前程序，转到相应的中断或异常处理程序</li>
<li>若中断或异常处理程序能解决问题，就在之后回到被打断的程序</li>
<li>若不能，则终止用户程序</li>
</ul>
<p>系统调用，操作系统为用户程序提供的一些可调用功能。</p>
<ul>
<li>设备管理、文件管理、进程控制、进程通信、内存管理</li>
<li>对于用户程序，与资源有关的操作<strong>由操作系统代为完成</strong>，运行在核心态</li>
<li>从用户态到核心态的转化，通过自陷（陷入、<strong>访管</strong>、trap）指令实现
<ul>
<li>可以说，<strong>系统调用通常是用自陷指令实现的</strong></li>
</ul>
</li>
</ul>
<h3 id="14-操作系统结构"><a class="markdownIt-Anchor" href="#14-操作系统结构"></a> 1.4 操作系统结构</h3>
<p>分层法，将操作系统分层，最底层（层 0）为硬件，最高层（层 N）为用户接口。</p>
<ul>
<li>单项依赖，每层只能调用紧邻的低一层</li>
<li>易于扩充和维护，但显得不灵活、运行效率差</li>
</ul>
<p>模块化，按功能划分为若干独立的模块，还能进一步划分子模块。模块间相对独立又相对联系。</p>
<ul>
<li>衡量模块独立性：
<ul>
<li>内聚性，模块内各个部分联系的紧密程度。越高越好</li>
<li>耦合度，模块间相互联系和相互影响的程度。越低越好</li>
</ul>
</li>
<li>便于开发与维护，但所规定的模块间的接口难满足需求，又因为模块间的依赖难以确定开发顺序</li>
</ul>
<p>宏内核，也称单内核或大内核，系统的主要功能模块都包含在核心态。</p>
<ul>
<li>性能优越</li>
</ul>
<p>微内核，最基本功能保留在内核，其它都在用户态运行。</p>
<ul>
<li>被移出内核的功能被划分为若干服务程序，相互独立执行，模块错误不会引起整个系统崩溃
<ul>
<li>基于 “客户/服务器” 模式</li>
</ul>
</li>
<li>程序调用服务，会借助微内核与服务进程进行通信</li>
<li>通常具有的功能：
<ul>
<li>进程（线程）管理，进程（线程）之间的通信、进程切换等</li>
<li>低级存储器管理，例如逻辑地址转换为物理地址。不包含类似采用哪种页面置换算法的管理</li>
<li>中断和陷入（trap）处理，响应中断并发送给相关服务来处理</li>
</ul>
</li>
<li>特点
<ul>
<li>扩展性和灵活性，可靠性和安全性，可移植性，分布式计算（适于分布式系统和网络系统）</li>
<li>问题在于性能。因为重要功能也在用户态，需要频繁切换用户态与核心态</li>
</ul>
</li>
</ul>
<p>外核，相比于虚拟机，是对机器的资源进行分区。</p>
<ul>
<li>优点是，相比于虚拟机减少了映射层，外核只需要记录分配出去的资源</li>
<li>还能将多道程序（外核内）与用户操作系统代码（用户空间内）加以分离</li>
</ul>
<h3 id="15-操作系统引导"><a class="markdownIt-Anchor" href="#15-操作系统引导"></a> 1.5 操作系统引导</h3>
<p>操作系统引导，CPU 通过 boot 程序，识别硬盘分区上的操作系统，从而启动操作系统。</p>
<p>具体过程如下，</p>
<ul>
<li>激活 CPU。读取 ROM 中的 boot 指令，IP 寄存器设为 BIOS 第一条指令，开始执行 BIOS</li>
<li>硬件自检。BIOS 程序会进行硬件自检</li>
<li>加载带有操作系统的硬盘。BIOS 转交控制权，CPU 加载存储设备引导扇区的内容到内存</li>
<li>加载主引导记录 MBR。根据标识符区查找引导硬盘，MBR 告诉去硬盘哪个分区加载操作系统</li>
<li>扫描硬盘分区表，加载硬盘活动分区。控制权交给活动分区</li>
<li>加载分区引导记录 PBR。这是活动分区的第一个扇区，用来寻找并激活 引导操作系统的程序</li>
<li>加载启动管理器。引导操作系统的程序被称为启动管理器</li>
<li>加载操作系统</li>
</ul>
<h3 id="16-虚拟机"><a class="markdownIt-Anchor" href="#16-虚拟机"></a> 1.6 虚拟机</h3>
<p>隐藏物理特性，提供抽象的计算环境。</p>
<p>两类虚拟化方法，</p>
<ul>
<li>第一类虚拟机管理程序，直接与硬件对接
<ul>
<li>在不支持虚拟化的 CPU 上，在内核态才允许执行的指令会转变为对虚拟机管理程序的调用</li>
</ul>
</li>
<li>第二类虚拟机管理程序，依赖于操作系统
<ul>
<li>宿主操作系统，被依赖的运行在底层硬件上的操作系统</li>
</ul>
</li>
</ul>
<p>客户操作系统，运行在两类虚拟机管理程序上的操作系统。</p>
<h2 id="第二章-进程与线程"><a class="markdownIt-Anchor" href="#第二章-进程与线程"></a> 第二章 进程与线程</h2>
<h3 id="21-进程与线程"><a class="markdownIt-Anchor" href="#21-进程与线程"></a> 2.1 进程与线程</h3>
<h4 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h4>
<p>进程，允许多个程序并发执行，实现操作系统的并发性和共享性。</p>
<ul>
<li>进程是进程实体的运行过程</li>
<li>进程实体是静态的，进程是动态的</li>
</ul>
<p>进程实体（进程映像），由一下部分部分构成，</p>
<ul>
<li><strong>进程控制块</strong>（Process Control Block, PCB），用来描述进程的情况和运行状态
<ul>
<li>创建进程实质上是创建 PCB，撤销实质上是撤销 PCB</li>
<li>PCB 包含的内容，
<ul>
<li>进程描述信息，
<ul>
<li>进程标识符，各个进程唯一</li>
<li>用户标识符，标识进程归属的用户。主要用来共享和保护</li>
</ul>
</li>
<li>进程控制和管理信息，
<ul>
<li>进程当前状态、进程优先级、代码运行入口地址等</li>
</ul>
</li>
<li>资源分配清单，
<ul>
<li>代码段指针、数据段指针、堆栈段指针、所打开文件和所占用设备等</li>
</ul>
</li>
<li>处理机相关信息，也称处理机的上下文
<ul>
<li>主要存储处理机中寄存器的值，如通用寄存器值、地址寄存器值、标志寄存器值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>程序段，能被调度到 CPU 执行的程序代码段。多个进程可共享同一程序</li>
<li>数据段，程序运行时的加工处理对象，包括全局变量和静态变量</li>
<li>栈，由编译器自动分配释放，存放各种变量。实现了函数调用</li>
<li>堆，由程序员分配释放。<code>malloc()</code> 申请的正是堆区</li>
</ul>
<p>进程的特征，</p>
<ul>
<li>动态性，进程具有生命周期，是动态地产生、变化和消亡的</li>
<li>并发性（可并发）、独立性（是独立运行的单位）、异步性（各自运行不同步）</li>
</ul>
<p>进程的状态，</p>
<ul>
<li>运行态，单处理机上只允许同时存在一个运行态进程</li>
<li>就绪态，进程获得了除处理机外所有资源
<ul>
<li>就绪队列，多个就绪进程排成队列</li>
</ul>
</li>
<li>阻塞态（等待态），进程为等待某事件而被暂停，例如等待 I/O、等待新任务
<ul>
<li>阻塞队列。有的会根据阻塞原因的不同，设置多个阻塞队列</li>
</ul>
</li>
<li>创建态，正被创建未就绪。所需资源不能被满足也会卡在创建态</li>
<li>结束态，将要被结束的进程会先进入结束态</li>
</ul>
<p>进程的状态切换，即进程控制</p>
<ul>
<li>进程的创建过程（创建原语），
<ul>
<li>分配进程标识符，申请一个空白 PCB，分配资源，初始化 PCB，插入就绪队列</li>
</ul>
</li>
<li>进程的终止（终止原语），包括正常结束、异常结束、外界干预
<ul>
<li>从 PCB 读出进程状态，终止进程，若有子孙进程则一并终止，释放资源，删除 PCB</li>
</ul>
</li>
<li>进程的阻塞（阻塞原语），进程在运行态时主动自我阻塞</li>
<li>进程的唤醒（唤醒原语），其它进程将被阻塞进程唤醒，转变为就绪态</li>
</ul>
<p>进程的通信。不同于 PV 操作，高级通信能高效率传输大量数据。高级通信方法主要如下：</p>
<ul>
<li>共享存储，通信的进程约定一块共享空间，共同读写
<ul>
<li>对共享空间的读写需要有同步互斥工具（如 PV 操作）进行控制</li>
</ul>
</li>
<li>消息传递，借助系统的原语进行数据交换。微内核与服务器就是采用这种方式
<ul>
<li>直接通信方式，发送方将信息发送到接收方的消息缓冲队列上</li>
<li>间接通信方式，发送方将消息发送到中间实体 “信箱”。广泛用于计算机网络</li>
</ul>
</li>
<li>管道通信，借助缓冲队列（管道）单方向通信</li>
</ul>
<h4 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h4>
<p>线程，进程的一个实体，被系统调度和分派的基本单位。“轻量级进程”。</p>
<p>线程与进程的比较，</p>
<ul>
<li>调度，线程的创建、切换、撤销的代价远低于进程</li>
<li>资源，线程只独有最低限度的系统资源（可以说不拥有系统资源），但可访问其隶属进程的资源
<ul>
<li>各个线程可以访问进程地址空间的每个单元，能读写另一个线程的堆栈</li>
</ul>
</li>
<li>与进程相似，线程也有一个唯一标识符、和一个线程控制块</li>
<li>与进程相似，线程也会经历阻塞态、就绪态、执行态</li>
</ul>
<p><strong>线程控制块</strong>（TCB），用来记录与管理线程信息。</p>
<ul>
<li>包含的内容，
<ul>
<li>线程标识符、寄存器信息、线程运行状态、优先级、专有存储区、堆栈指针</li>
</ul>
</li>
</ul>
<p>线程的实现方式，分为两类，</p>
<ul>
<li>用户级线程（ULT），线程管理的操作在用户空间中完成
<ul>
<li>内核无法感知到线程的存在，系统调度仍然按照一个进程的单位分配时间片</li>
<li>优点是，节省了模式切换的开销，灵活易实现</li>
<li>缺点是，发生阻塞会使所有进程都被阻塞，也不能发挥多处理机的优势</li>
</ul>
</li>
<li>内核级线程（KLT），在内核的支持下运行
<ul>
<li>优点是，线程阻塞不牵连其它线程，能更好支持多处理机</li>
<li>缺点是，线程的切换需要进行模式切换，系统开销大</li>
</ul>
</li>
<li>于是就有了两者组合的方式。用户级线程与内核级线程可以多对多</li>
</ul>
<h3 id="22-处理机调度"><a class="markdownIt-Anchor" href="#22-处理机调度"></a> 2.2 处理机调度</h3>
<h4 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h4>
<p>处理机调度，合理地为进程分配处理机，以实现进程并发执行。</p>
<p>三级调度，一个作业从提交到完成要经历三级调度：</p>
<ul>
<li>高级调度（作业调度），以作业为单位进行挑选，加载到内存，分配必要资源，建立进程
<ul>
<li>多用于多道批处理系统，其它系统通常不需要作业调度</li>
</ul>
</li>
<li>中级调度（内存调度），将暂时不运行的进程移到外存，进程被挂起。swap 技术</li>
<li>低级调度（进程调度），从就绪队列中选择进程，分配处理机。调度频率相当高
<ul>
<li>不可或缺，各种操作系统都必须配置这级调度</li>
</ul>
</li>
</ul>
<p>调度的性能指标，</p>
<ul>
<li>系统吞吐量，单位时间内完成作业的数量</li>
<li><strong>周转时间</strong>，从作业提交到作业完成花费的时间。包括作业在就绪队列的等待时间</li>
<li><strong>带权周转时间</strong>，周转时间 / 作业实际执行时间。总是大于 1，按理说越小越好</li>
</ul>
<p>调度算法的实现，</p>
<ul>
<li>调度程序（调度器），通常有三部分：
<ul>
<li>排队器，将就绪进程按某种策略排成一个或多个队列
<ul>
<li>排队器会将转变为就绪态的进程插入到相应的就绪队列中</li>
</ul>
</li>
<li>分派器，从就绪队列里取出进程，分配处理机</li>
<li>上下文切换器，用于进程切换。CPU 的上下文是指寄存器和程序计数器的内容
<ul>
<li>保存旧进程的上下文到 PCB，装载分派程序上下文，装载新进程的 CPU 现场信息</li>
</ul>
</li>
</ul>
</li>
<li>特殊情况下必须暂停进程的调度与切换：
<ul>
<li>处理中断的时候、进程在操作系统内核临界区中、是原子操作（如原语）</li>
</ul>
</li>
</ul>
<p>进程调度方式，对于优先权更高的进程如何分配处理机，</p>
<ul>
<li>非抢占调度方式（非剥夺方式），等待正在执行的进程进入阻塞态
<ul>
<li>简单高效，但不适用于分时操作系统</li>
</ul>
</li>
<li>抢占调度方式（剥夺方式），根据某种原则去暂停正在执行的进程</li>
</ul>
<p>闲逛进程（idle），没有就绪进程时运行该进程。不需要 CPU 以外的资源，不会被阻塞。</p>
<h4 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h4>
<p>常用的调度算法，</p>
<ul>
<li>先来先服务（First Come First Serve, FCFS）调度算法
<ul>
<li>属于不可剥夺算法，执行简单但效率低</li>
</ul>
</li>
<li>短作业优先（Shortest Job First, SJF）调度算法
<ul>
<li>同样不可剥夺，且用作调度依据的作业运行时间是预估得来的</li>
<li>在指标上，拥有最少的平均等待时间、最少的平均周转时间。毕竟是等的短作业先完成</li>
</ul>
</li>
<li>优先级调度算法
<ul>
<li>优先级为调度依据。分为抢占式和非抢占式</li>
<li>优先级可以是静态优先级、动态优先级</li>
<li>进程优先级的设置原则：系统&gt;用户，交互（前台）&gt;非交互（后台），I/O 型&gt;计算型</li>
</ul>
</li>
<li>高响应比优先调度算法
<ul>
<li>同时考虑作业的等待时间与预估运行时间
<ul>
<li>响应比 = (等待时间 + 预估运行时间) / 预估运行时间，可见初始为 1，会越来越大</li>
</ul>
</li>
<li>主要用于作业调度，是对 FCFS 和 SJF 的平衡</li>
</ul>
</li>
<li>时间片轮转调度算法
<ul>
<li>就绪队列里的进程依次循环，使用一个时间片</li>
</ul>
</li>
<li>多级队列调度算法
<ul>
<li>与上面算法的单一就绪队列不同，这里有多个就绪队列</li>
</ul>
</li>
<li>多级反馈队列调度算法
<ul>
<li>设置多个优先级不同的就绪队列，各个队列有不同的时间片大小，每个队列采用 FCFS 算法</li>
<li>新进程首先进入第 1 级队列末尾。若在一个时间片内未完成，则被转入第 2 级……</li>
<li>仅第 1 级队列为空时，才会调度第 2 级队列中的进程……</li>
</ul>
</li>
</ul>
<h4 id="进程切换"><a class="markdownIt-Anchor" href="#进程切换"></a> 进程切换</h4>
<p>进程切换，在内核支持下完成上下文切换。</p>
<p>上下文切换，处理机所执行进程的切换。流程如下，</p>
<ul>
<li>进程被挂起，保存 CPU 上下文，包括程序计数器和其它寄存器</li>
<li>更新 PCB 信息，将进程的 PCB 移入相应队列（就绪、某事件的阻塞队列）</li>
<li>选择下一个进程，更新 PCB，装载新的 CPU 现场信息</li>
</ul>
<p>模式切换与进程切换不一样，模式切换后 CPU 可能还在执行同一进程，不需要上下文切换。</p>
<h3 id="23-同步与互斥"><a class="markdownIt-Anchor" href="#23-同步与互斥"></a> 2.3 同步与互斥</h3>
<p>进程同步，在多道程序环境下协调进程之间的相互制约关系。</p>
<p>与进程的同步互斥相关的机制：</p>
<ul>
<li>临界资源，仅允许同时一个进程使用的共享资源
<ul>
<li>临界资源的访问代码可分为 4 个部分，
<ul>
<li>进入区，检查是否可进入临界区，设置正访问标志防止其它程序进入</li>
<li>临界区，访问临界资源的代码</li>
<li>退出区，清除访问标志</li>
<li>剩余区，最后运行的其它代码</li>
</ul>
</li>
</ul>
</li>
<li>同步，控制执行顺序，保证因果关系</li>
<li>互斥（间接制约关系），体现在临时资源的访问</li>
</ul>
<p>实现临界区互斥的方法，</p>
<ul>
<li>软件实现，
<ul>
<li>单标志法，设置一个公用变量 <code>turn</code> 指示进程编号，只允许这个进程访问临界区
<ul>
<li>出现的问题：进程访问完毕后不能再次进入临界区，要等其它进程访问后设回标志</li>
</ul>
</li>
<li>双标志法先检查，维护一个标识各个进程是否访问临界区的数组 <code>flag</code>
<ul>
<li>进入临界区前，设置数组对应位置为 True。进程每次访问会先检查数组</li>
<li>缺点是，数组的写入与检查有时延，可能会有多个进程同时进入临界区</li>
</ul>
</li>
<li>双标志法后检查，在上一算法的基础上，改成了：在写入数组之后才检查数组
<ul>
<li>但依然解决不了问题。多个进程同时想进入临界区则会 “相互谦让”，造成饥饿现象</li>
</ul>
</li>
<li>Peterson’s Algorithm，设置一个公用变量指示进程编号，维护一个数组标识进程是否访问
<ul>
<li><strong><code>flag</code> 与 <code>turn</code> 的结合</strong></li>
<li>意欲访问临界区的进程，会先设置数组对应位置为 True</li>
<li>将 <code>turn</code> <strong>置为另一个线程</strong>，自己则等待另一个线程的的 <code>flag</code> 为 False 或 <code>turn</code> 不指向那个线程
<ul>
<li>就是说，先<strong>把执行权交给另一个线程</strong></li>
<li>这个交付有先后顺序，后交付会令先交付继续执行。避免了冲突和饥饿</li>
</ul>
</li>
<li>不允许让权等待。存在 <code>while</code> 语句持续检测条件</li>
</ul>
</li>
</ul>
</li>
<li>硬件实现。被称为低级方法，或元方法，
<ul>
<li>中断屏蔽方法，关中断防止进程切换
<ul>
<li>将关中断的权利交给用户不是很明智</li>
</ul>
</li>
<li>硬件指令方法，使用一系列不可打断的原子操作
<ul>
<li>会围绕一个共享布尔变量 <code>lock</code> 达成上锁的目的，而操作都是原子性的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>互斥锁，一种解决临界区问题的简单工具。</p>
<ul>
<li>互斥锁有布尔变量 <code>available</code>、获得锁函数 <code>acquire()</code>、释放锁函数 <code>release()</code></li>
<li>函数执行必须是原子操作，所以互斥锁通常用硬件实现</li>
<li>缺点是，其它进程想要进入临界区就必须连续调用 <code>acquire()</code> 函数</li>
</ul>
<p>信号量，管理等待队列的方法，解决互斥与同步问题。</p>
<ul>
<li>信号量 <code>S</code> 的值，可以说代表了队列的剩余容量
<ul>
<li>初始值为 1，或为资源的访问上限</li>
<li>进程入队会使得信号量减 1</li>
<li>信号量为 0 时，所有后续的进程处于等待状态</li>
</ul>
</li>
<li>信号量只能被两个原语访问和修改：
<ul>
<li>P 操作，<code>wait(S)</code>，用于资源的调用
<ul>
<li>先信号量减 1，若 <code>S</code> 值小于 0，则进程被阻塞进入等待队列</li>
</ul>
</li>
<li>V 操作，<code>signal(S)</code>，用于资源的释放
<ul>
<li>先信号量加 1，若 <code>S</code> 值小于等于 0，则从等待队列唤醒进程；<code>S</code> 大于 0，直接释放</li>
</ul>
</li>
<li>P/V 操作不一定对应。可以对信号量 1 进行 P 操作后，对信号量 2 进行 V 操作</li>
</ul>
</li>
<li>用信号量实现进程同步时，信号量的值会动态变动</li>
</ul>
<p>管程，将共享资源的相关操作进行封装，每次仅允许一个进程进入管程。</p>
<ul>
<li>就是将共享资源封装为类（但无法实例化），类包含资源本身和一系列操作函数</li>
<li>管程的组成：
<ul>
<li>管程的名称</li>
<li>资源的数据结构说明</li>
<li>对数据结构进行操作的一系列函数</li>
<li>对数据结构的初始化语句</li>
</ul>
</li>
<li>条件变量，保证管程只能被单个进行使用
<ul>
<li>对应着一个等待队列</li>
<li>条件变量不满足时进程用 <code>wait()</code> 进队，资源释放后被 <code>signal()</code> 唤醒</li>
</ul>
</li>
</ul>
<p>实际的同步问题，</p>
<ul>
<li>信号量在实际使用中，P/V 操作不一定对应。因为往往会有多个信号量</li>
<li>只需要记住：对值的修改都需要先进行 P 操作</li>
<li>注意防止死锁</li>
<li>让权等待：
<ul>
<li>无法进入临界区的进程，会立即释放处理机</li>
<li>不允许让权等待的算法，阻塞不体现在进入等待队列，而是体现在 <code>while(True)</code> 死循环</li>
</ul>
</li>
</ul>
<h3 id="24-死锁"><a class="markdownIt-Anchor" href="#24-死锁"></a> 2.4 死锁</h3>
<p>死锁，多个进程因竞争资源而可能陷入的僵局。</p>
<p>死锁产生的几个必要条件，</p>
<ul>
<li>互斥使用，资源只能被一个进程独占</li>
<li>不可剥夺，进程获得资源后只能主动释放资源</li>
<li>请求并保持，进程独占了一个资源，并又请求了新的资源</li>
<li>循环等待，链中每个进程都等待下一个进程释放资源</li>
</ul>
<p>死锁的预防（破坏死锁条件），</p>
<ul>
<li>破坏 “不可剥夺” 条件，进程申请新的资源不能立即满足而进入等待状态之前，必须释放占有的所有资源</li>
<li>破坏 “请求和保持” 条件，进程运行之前必须一次性申请它所要求的资源，避免动态分配</li>
<li>破坏 “循环等待” 条件，采用<strong>资源有序分配法</strong>，把系统中所有资源编号，各个进程在申请资源时必须严格按照资源编号的递增次序进行
<ul>
<li>编号必须稳定，限制了新设备的添加；进程对资源的使用不一定符合编号顺序，有资源浪费</li>
</ul>
</li>
</ul>
<p>死锁的避免（防止进入不安全状态），</p>
<ul>
<li>系统安全状态，避免系统进入不安全状态
<ul>
<li>安全状态，系统能找到一个安全序列</li>
<li><strong>安全序列</strong>，对于当前的进程序列，存在一种资源的分配与释放方案，使得某个进程后续所需资源不超过系统当前剩余的资源总量（即，<strong>至少有一个进程能被释放</strong>）</li>
<li>进入不安全状态不意味着陷入死锁，但处于安全状态能完全避免死锁</li>
</ul>
</li>
<li>银行家算法，银行家拥有一笔周转资金，客户承诺定期归还贷款。所有投资都能被收回，则安全
<ul>
<li>进程会声明资源的最大需求量。当进程继续申请资源时，系统会进行判断：
<ul>
<li>若已占用与欲申请资源之和大于所声明的最大需求量，则拒绝</li>
<li>若系统剩余资源能满足进程的最大需求量，则同意本次申请</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>死锁的检测，</p>
<ul>
<li>资源分配图
<ul>
<li>画法，
<ul>
<li>圆圈代表进程，方框代表资源，方框中的圆圈代表资源数量</li>
<li>箭头，资源指向进程代表分配（分配边），进程指向资源代表申请（申请边）</li>
</ul>
</li>
<li>观察是否死锁，
<ul>
<li>基本思路依然是寻找安全序列，不断去掉箭头。若图不可完全简化，则处在死锁状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>死锁的解除，</p>
<ul>
<li>资源剥夺法，从其他进程剥夺足够数量的资源给死锁进程</li>
<li>撤销进程法，撤销全部死锁进程，或者逐个撤销死锁进程</li>
<li>进程回退法，退回到历史还原点。也相当于终止所有死锁进程</li>
</ul>
<h2 id="第三章-内存管理"><a class="markdownIt-Anchor" href="#第三章-内存管理"></a> 第三章 内存管理</h2>
<h3 id="31-内存管理概念"><a class="markdownIt-Anchor" href="#31-内存管理概念"></a> 3.1 内存管理概念</h3>
<p>内存管理，主要内容有：</p>
<ul>
<li>内存空间的分配与回收，操作系统代程序员进行分配</li>
<li>地址转换，程序的逻辑地址与内存的物理地址相转换</li>
<li>内存空间的扩充，利用虚拟存储技术或自动覆盖技术</li>
<li>内存共享，多个进程访问同一部分内存</li>
<li>存储保护，保证各道独立运行</li>
</ul>
<h4 id="进程与地址"><a class="markdownIt-Anchor" href="#进程与地址"></a> 进程与地址</h4>
<p>程序和数据装入内存的过程，</p>
<ul>
<li><strong>编译</strong>，编译程序将源代码编译成若干目标模块</li>
<li><strong>链接</strong>，链接程序将目标模块与所需的函数库链接在一起，形成装入模块
<ul>
<li>静态链接，提前将目标模块与所需库函数链接成一个装配模块
<ul>
<li>因为编译后的目标模块都是从 0 开始的相对地址，封装装入模块需要修改相对地址</li>
<li>模块中所用的外部调用符号也都变换为相对地址</li>
<li>可以说，静态链接的意义是<strong>映射到连续的地址</strong></li>
</ul>
</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
</li>
<li><strong>装入</strong>，装入程序将装入模块装入内存
<ul>
<li>绝对装入，编译时就确定绝对地址
<ul>
<li>只适用于单道程序环境</li>
</ul>
</li>
<li>可重定位装入，装入模块中的地址依然是逻辑地址，直到装入环节才确定物理地址
<ul>
<li>作业一旦进入内存，就不可移动也不可再申请空间</li>
</ul>
</li>
<li>动态运行时装入，装入内存后不会立即把逻辑地址转换为物理地址，直到程序运行
<ul>
<li>需要一个重定位寄存器支持</li>
<li>程序可被分配不连续空间；不必装入所有代码；可动态申请空间；便于程序段共享</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>逻辑地址与物理地址，</p>
<ul>
<li>逻辑地址，又称相对地址
<ul>
<li>编译后每个目标模块从 0 号单元开始编址</li>
<li>链接后模块被分配到从 0 号单元开始编址的逻辑地址空间（或称虚拟地址空间）</li>
</ul>
</li>
<li>物理地址，实际执行所需要的地址
<ul>
<li>地址重定位，逻辑地址转换成物理地址的过程</li>
<li>操作系统通过内存管理部件（MMU）将进程使用的逻辑地址转换为物理地址</li>
</ul>
</li>
</ul>
<p>进程的内存映像（进程实体 / 进程映像），见 2.1 进程与线程。</p>
<p>内存保护，有两种方法，</p>
<ul>
<li>在 CPU 中设置一堆上下限存储器，每次访问都先对比，判断是否越界</li>
<li>使用界地址寄存器（限长寄存器）和重定位寄存器（基地址寄存器）来实现，
<ul>
<li>CPU 要访问的逻辑地址，先被界地址寄存器检测是否越界，再被重定位寄存器变为物理地址</li>
<li>界地址寄存器包含逻辑地址最大值，重定位寄存器包含物理地址最小值（就是偏移地址）</li>
<li>仅允许操作系统内核修改者两个寄存器的值</li>
</ul>
</li>
</ul>
<p>内存共享，只有只读区域才可以被共享。</p>
<ul>
<li>可重入代码，又称为纯代码，允许多个进程同时访问，但不允许被修改</li>
</ul>
<h4 id="内存的分配分区-页式-段式"><a class="markdownIt-Anchor" href="#内存的分配分区-页式-段式"></a> 内存的分配（分区、页式、段式）</h4>
<ul>
<li>覆盖与交换技术
<ul>
<li>覆盖和交换技术都是用来扩充内存的方法。使得较大程序运行在较小的内存空间</li>
<li><strong>覆盖</strong>，根据程序各个程序段的调用关系，选择性不装载一部分不存在调用关系的程序段
<ul>
<li>用于早期的单一连续分配方式</li>
</ul>
</li>
<li><strong>交换技术</strong>，以进程或作业为单位，把内存中暂时不能运行的进程或数据换出到外存，把具备运行条件的进程或数据换入到内存运行</li>
</ul>
</li>
</ul>
<p><strong>连续分配管理方式（分区存储管理）</strong>，为一个用户程序分配一个连续的内存空间，</p>
<ul>
<li>单一连续分配，内存被分为系统区和用户区，用户区中仅有一道用户程序
<ul>
<li>简单、无外部碎片、无需进行内存保护</li>
</ul>
</li>
<li>固定分区分配，将用户内存空间划分为若干固定大小的区域，每个区域一道作业
<ul>
<li><strong>分区说明表</strong>，包含分区的起始地址、大小、分配状态</li>
<li>是最简单的一种多道程序存储管理方式</li>
</ul>
</li>
<li>动态分区分配，又称可变分区分配
<ul>
<li>不是再系统启动时划分，而是在作业处理过程中建立</li>
<li>外部碎片，此时内存会随着时间推移逐渐碎片化</li>
</ul>
</li>
</ul>
<p>针对动态分区产生的空闲块，有如下分配算法：</p>
<ul>
<li>首次适应算法（first fit），顺序查找大小满足要求的空闲区，根据作业大小划出空间
<ul>
<li>从未分配区表的开始位置查找，导致低地址短留下许多难以利用的小空闲区</li>
</ul>
</li>
<li>循环首次适应算法（next fit），又称临近适应算法，是从上次找到的空闲区开始查找
<ul>
<li>比起首次适应算法，存储空间的利用更均衡。但会导致系统缺乏大的空闲区</li>
</ul>
</li>
<li>最佳适应算法（best fit），将空闲区按容量大小递增次序排列，找到刚好满足需求的空闲区
<ul>
<li>会使存储器中留下许多难以利用的小空闲区</li>
</ul>
</li>
<li>最坏适应算法（worst fit），将空闲区按容量大小递减的次序排列，先检查未分配表中的第一个空闲区，若不合适则分配失败
<ul>
<li>会导致系统缺乏大的空闲区，系统难以满足大作业的存储空间申请</li>
</ul>
</li>
</ul>
<p><strong>页式存储管理</strong>，</p>
<ul>
<li>一些概念，
<ul>
<li>页框（页帧），把<strong>内存空间</strong>划分为大小相等的区域，每个块被称为页框</li>
<li>页面（页），把<strong>程序逻辑地址空间</strong>按页框大小划分，不足一页则补足一页，被称为页面</li>
<li>逻辑地址形式，分页存储管理下的逻辑地址由两部分组成：页号，页内地址</li>
</ul>
</li>
<li>页表，系统为每个装入内存的进程建立一张页表，其条目（页表项）指出页在内存中的页框号
<ul>
<li>页表项，页表中的条目</li>
<li>页框号，一般会对应物理地址。乘上偏移地址的上限即可转换为页框的开始物理地址</li>
</ul>
</li>
<li>页式地址转换，进程逻辑地址转换为内存物理地址的过程
<ul>
<li>转换过程由硬件自动完成</li>
<li>页表寄存器（PTR），存放页表在地址的起始地址和页表长度</li>
<li>快表（TLB），又称为相联存储器，是一个具有并行查找能力的高速缓冲存储器
<ul>
<li>存储部分页表项，加速读取速度</li>
</ul>
</li>
<li>慢表，存储在主存的页表。通过慢表访问物理地址的话，相当于要访问两次内存</li>
<li>二级页表，建立一张管理页表的页表
<ul>
<li>意味着，逻辑地址的转换需要经过三步：访问页目录、访问页表页、访问物理地址</li>
<li>此时的逻辑地址由三部分组成：一级页号（页目录表），二级页号（页表），页内偏移</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>段式存储管理</strong>，</p>
<ul>
<li><strong>分段和分页的比较</strong>
<ul>
<li>两者都采用离散分配方式，都要通过地址映射机构来实现地址变换</li>
<li>页的大小固定，由系统确定；段的长度不定，取决于用户所编写的程序</li>
<li>页是物理单位，段是逻辑单位</li>
<li>地址空间方面，分页是一维的（只用一个地址），分段是二维的（需要段名、段内地址）</li>
</ul>
</li>
<li>段表，系统为每个装入内存的进程建立一张段表，记录每段在内存中的始址和长度
<ul>
<li>与页表不同的是，不使用页框号与内存对应，而是直接用偏移地址</li>
</ul>
</li>
<li>在用户编程阶段决定了程序的分段。程序按照逻辑被划分为几个逻辑段
<ul>
<li>回忆汇编时分为的 DATA 段、代码段等。所以段式提供二维地址结构</li>
</ul>
</li>
</ul>
<p><strong>段页式管理</strong>，作业的地址空间被分为若干逻辑段，然后每段被分为页面。</p>
<ul>
<li>分页能提高内存利用率，分段有利于段的共享与保护</li>
<li>逻辑地址形式，分为三部分：段号、页号、页内偏移地址</li>
<li>段表只有一个，页表可能有多个</li>
</ul>
<h3 id="32-虚拟内存管理"><a class="markdownIt-Anchor" href="#32-虚拟内存管理"></a> 3.2 虚拟内存管理</h3>
<p>虚拟内存，将主存部分内容暂放到虚拟存储器（速度更慢但更大）。</p>
<ul>
<li>虚拟内存技术实际上建立了 “内存-外存” 的两级存储器结构，利用局部性原理实现高速缓存</li>
</ul>
<p>局部性原理，</p>
<ul>
<li>时间局部性，某条指令被执行，不久之后可能再执行；某个数据被访问，不久后可能再访问</li>
<li>空间局部性，某存储单元被访问，不久后其附近的存储单元也将被访问</li>
</ul>
<h4 id="基于页面的管理系统"><a class="markdownIt-Anchor" href="#基于页面的管理系统"></a> 基于页面的管理系统</h4>
<p>请求分页系统，以页为单位管理虚拟内存。</p>
<ul>
<li>页表，要考虑访问的页不在内存的情况
<ul>
<li>除了 页号、物理块号，额外有 状态位、访问字段、修改位、外存地址
<ul>
<li>状态位，该页是否已调入内存</li>
<li>访问字段，该页在一段时间内被访问的次数，或该页有多长时间未被访问</li>
<li>修改位，该页在调入内存后是否被修改过，用来确定页面置换时是否写回外存</li>
<li>外存地址，通常时物理块号</li>
</ul>
</li>
</ul>
</li>
<li>缺页中断，要访问的页面不再内存中时产生一个缺页中断
<ul>
<li>与一般中断相比，是在一条指令执行期间产生的中断信号，而不是指令执行完毕而产生</li>
<li>一条指令执行期间，可能产生多次缺页中断</li>
</ul>
</li>
<li>地址变换，在分页系统地址变换的基础上，支持缺页中断、页面置换等情况的地址变换</li>
</ul>
<p>页框的分配方式，针对页面置换与内存空间，</p>
<ul>
<li>驻留集，给一个进程分配的物理页框。为了更好的性能与并行性，驻留集要适量</li>
<li>内存分配策略，关于 确定进程物理块数量 和 物理块置换方法 的策略
<ul>
<li>固定分配局部置换，
<ul>
<li>进程被分配的物理块数量固定，发生置换时只能从当前进程的物理块中选择</li>
<li>关于分配到的物理块数量，有如下方案：
<ul>
<li>平均分配算法，所有物理块平均分配给各个进程</li>
<li>按比例分配算法，根据进程的大小按比例分配</li>
<li>优先权分配算法，为高优先权进程分配更多物理块。通常结合 按比例分配算法 使用</li>
</ul>
</li>
</ul>
</li>
<li>可变分配全局置换，
<ul>
<li>进程被分配的物理块数量不固定，发生置换时从全局的空闲物理块中选择</li>
<li>会影响到其它进程。并发能力下降</li>
</ul>
</li>
<li>可变分配局部置换，
<ul>
<li>进程被分配的物理块数量不固定，发生置换时只能从当前进程的物理块中选择</li>
<li>若缺页中断过多，就添加物理块，反之减少物理块</li>
</ul>
</li>
</ul>
</li>
<li>调入页面的时机：
<ul>
<li>预调页策略，将预计将被访问的页面预先调入内存
<ul>
<li>主要用于进程的首次调入（运行前的调入）</li>
</ul>
</li>
<li>请求调页策略，进程运行过程中提出调入页面请求</li>
</ul>
</li>
<li>调入页面的来源，
<ul>
<li>在请求分页系统中，外存被分为两部分：
<ul>
<li>文件区，离散分配</li>
<li>对换区，连续分配，速度更快</li>
</ul>
</li>
<li>缺页调入此时就有三种方式：
<ul>
<li>从对换区调入，针对对换区空间充足的情况
<ul>
<li>需要提前将文件复制到对换区</li>
</ul>
</li>
<li>从文件区调入，不会被修改的文件都从文件区调入。针对对换区空间不够的情况
<ul>
<li>因为不会被修改，所以无需将这些页面换出</li>
</ul>
</li>
<li>UNIX 方式，未运行过的页面都从文件区调入，换出时换到对换区</li>
</ul>
</li>
</ul>
</li>
<li>调入页面的方式，
<ul>
<li>若访问到不在内存的页面，向 CPU 发出缺页中断，进行调入</li>
<li>调入时若内存不够就需要进行换出。如果该页未被修改过，则无需写回磁盘</li>
</ul>
</li>
</ul>
<p>页面置换算法，选择哪些页面调出，</p>
<ul>
<li>最佳置换算法（OPT）
<ul>
<li>选择永不使用的，或最长时间内不再被访问的，页面进行置换</li>
<li>是理想化的算法，难以实现，具有最好的性能</li>
</ul>
</li>
<li>先进先出置换算法（FIFO）
<ul>
<li>内存中驻留最久的页面先被淘汰。可用循环链表实现</li>
<li>实现简单，但性能较差</li>
<li>可分配页帧增加时，FIFO 的缺页率可能反而会上升</li>
</ul>
</li>
<li>最近最久未使用置换算法（LRU, Least Recently Used）
<ul>
<li>选择一段时间内最长时间没有被访问过的页面进行置换</li>
<li>性能较好，需要寄存器和栈的硬件支持</li>
</ul>
</li>
<li>时钟置换算法（Clock）/最近未使用算法（NRU）
<ul>
<li>是 LRU 和 FIFO 的折衷算法。将所有页面链接成循环队列，每页有一位访问位</li>
<li>设置一个指针，只在置换时用来遍历，不跳转
<ul>
<li>遍历时，先移位指针再进行访问位检查与修改</li>
</ul>
</li>
<li>若某页被访问，其访问位设为 1（指针不动）。置换时检查访问位，若是 0 则换出，若是 1 则恢复成 0，再按照 FIFO 算法检查下一个页面</li>
<li>改进的 CLOCK 置换算法：引入修改位，指示页面是否被修改，降低写回代价
<ul>
<li>缺点是可能需要好几轮扫描</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="抖动和工作集"><a class="markdownIt-Anchor" href="#抖动和工作集"></a> 抖动和工作集</h4>
<p>抖动（颠簸），在页面置换过程中，页面被反复移入与移出主存。</p>
<p>工作集，在某段时间间隔内，进程要访问的页面集合。</p>
<ul>
<li>基于局部性原理，可以用最近访问的页面来确定工作集
<ul>
<li>工作集窗口，用来确定进程工作集。其原理是 “向前看指定数目的被访问的页面”
<ul>
<li>向前看一定数量，统计被访问到的页面。所以统计出的数目不一定等于向前看数量</li>
</ul>
</li>
</ul>
</li>
<li>为了避免抖动，若所有进程的工作集大小之和超过可用物理块数，系统应暂停一个进程</li>
</ul>
<p>抖动就是缺页率高。为了降低抖动：</p>
<ul>
<li>页面较大，缺页率较低，页内碎片增大；页面较小，缺页率较高，页内碎片减小</li>
<li>增多物理块。但为了不浪费，只要能保持较低缺页率即可</li>
<li>程序局部化程度越高，缺页率越低</li>
</ul>
<h4 id="内存映射文件"><a class="markdownIt-Anchor" href="#内存映射文件"></a> 内存映射文件</h4>
<p>内存映射文件，建立 磁盘文件 与 进程虚拟地址空间 的映射关系。</p>
<ul>
<li>将磁盘文件搬到了内存。只有进程退出或解除文件映射时，有改动的页面才会被写回磁盘</li>
<li>允许多进程共享内存映射文件，并借由进行进程间的通信</li>
</ul>
<h4 id="地址翻译"><a class="markdownIt-Anchor" href="#地址翻译"></a> 地址翻译</h4>
<p>与《计算机组成》的学科交叉。在操作系统书的p211【】</p>
<h2 id="第四章-文件管理"><a class="markdownIt-Anchor" href="#第四章-文件管理"></a> 第四章 文件管理</h2>
<h3 id="41-文件"><a class="markdownIt-Anchor" href="#41-文件"></a> 4.1 文件</h3>
<p>文件，是用户程序的输入输出单位。</p>
<ul>
<li>文件的三级结构，
<ul>
<li>数据项，例如描述一个学生的基本数据项有学号、姓名等
<ul>
<li>基本数据项，描述对象的某种属性的一个值</li>
<li>组合数据项，由多个基本数据项组成</li>
</ul>
</li>
<li>记录，一组相关数据项的集合</li>
<li>文件，其逻辑结构分为 有结构（若干相似记录组成）和 无结构（例如一个二进制文件）</li>
</ul>
</li>
</ul>
<p>文件的逻辑结构，决定用户方可见的结构（类比虚拟地址），</p>
<ul>
<li>无结构文件（流式文件）
<ul>
<li>以字节（Byte）为单位，其访问只能通过穷举搜索的方式</li>
</ul>
</li>
<li>有结构文件（记录式文件）
<ul>
<li>按组织形式，又可分为：
<ul>
<li>顺序文件，文件中的记录依次排列</li>
<li>索引文件，有一张索引表，表项指向记录的指针</li>
<li>索引顺序文件，顺序文件与索引文件的结合，即为一个顺序文件建立一张索引表
<ul>
<li>本质是为顺序文件的记录分组，加速查找过程</li>
</ul>
</li>
<li>直接文件 / 散列文件（Hash File），键值直接决定记录的物理地址
<ul>
<li>速度极快，但可能发生冲突</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>文件的物理结构，如何为文件分配磁盘块（即，以物理块为单位进行存取），</p>
<ul>
<li>连续分配，在磁盘上占有一组连续的块</li>
<li>链接分配，一种离散分配方式
<ul>
<li>隐式链接，类似于链表，每个盘块都有指向下一个盘块的指针。对用户是透明的
<ul>
<li>簇，不按盘块来分配，而是更大的簇。改善顺序访问的速度，但增加了内部碎片</li>
</ul>
</li>
<li>显式链接，将硬盘的所有物理块的指针存放在一张链接表中，用下标代替指针
<ul>
<li>文件分配表（FAT, File Allocation Table）
<ul>
<li>每个表项存储了 盘块号、下一块
<ul>
<li>若下一块为负数，则代表来到了文件的末尾</li>
</ul>
</li>
<li>文件目录表的表项会指向一个起始块号。要读取文件，会根据起始块号查阅文件分配表，开始遍历下一块，直到下一块的下标为负数</li>
</ul>
</li>
<li>依靠 FAT 表的查找，其过程是在内存中进行的。所以性能较好</li>
</ul>
</li>
</ul>
</li>
<li><strong>索引分配</strong>，对一个文件使用一个索引块表，将盘块号按顺序录入到其中
<ul>
<li>索引块表，又称为索引块。将索引集中存放在一个磁盘块中</li>
<li>为了让索引块支持存储大文件，有如下解决方案：
<ul>
<li>链接方案，将多个索引块链接起来</li>
<li>多层索引，第一级索引块指向第二级之类的</li>
</ul>
</li>
</ul>
</li>
<li>混合索引，为了顾及到不同大小的文件，根据情况使用索引方法
<ul>
<li>直接地址，直接存放盘块号，存放不大于 40 kb 的文件</li>
<li>一次间接地址，使用索引分配，存放不大于 4 mb 的文件</li>
<li>多次间接地址，即多层索引</li>
</ul>
</li>
</ul>
<p>文件目录，创建文件会分配一个 FCB 作为<strong>目录项</strong>存放在文件目录中。</p>
<ul>
<li>文件控制块（FCB），赋予数据以文件的意义，令文件可被视为个体
<ul>
<li>文件元数据，又称文件属性，存储诸如所有者、创建时间等信息。包含在 FCB 中</li>
</ul>
</li>
<li>一个文件目录页被视为文件，称为目录文件</li>
</ul>
<p>索引结点，针对文件目录的目录项，分离文件名与文件描述信息，加快检索目录的速度</p>
<ul>
<li>文件描述信息单独形成一个数据结构，这就是索引结点</li>
<li>此时，文件目录中的目录项是由<strong>文件名</strong>和<strong>指向索引结点的指针</strong>构成的
<ul>
<li>检索就只需要检索文件名，而不需要读取索引结点中的其它信息。加快了检索速度</li>
</ul>
</li>
<li><strong>inode，i 结点，就是索引结点</strong>。在分区中被放在超级块之后</li>
<li>磁盘索引结点，存放在磁盘上的索引结点。每个文件都有唯一的磁盘索引结点</li>
<li>内存索引结点，存放在内存中的索引结点。磁盘索引结点被复制到内存，并增加了额外内容</li>
</ul>
<p>文件的相关操作，</p>
<ul>
<li>创建文件，包括分配外存空间、在目录中创建目录项</li>
<li>写文件，对于给定文件名执行系统调用。系统维护一个写位置指针。通常与读文件共用指针</li>
<li>读文件，对于给定文件名执行系统调用。系统维护一个读位置指针。通常与写文件共用指针</li>
<li>重定位新文件，也称文件定位，搜索目录，重定位当前文件位置指针</li>
<li>删除文件，从目录中检索到目录项，释放对应存储空间，删除目录项</li>
<li>截断文件，仅删除文件的内容，数据长度变为 0</li>
</ul>
<p>文件的打开与关闭，</p>
<ul>
<li>两级表：
<ul>
<li><em>进程的打开文件表</em>，该进程打开的文件
<ul>
<li>其条目指向系统表的相应条目</li>
</ul>
</li>
<li><em>系统的打开文件表</em>，包含了所有被打开的文件
<ul>
<li>其条目指向文件的具体位置</li>
<li>不采用文件名作为索引，而是使用<em>文件描述符</em>（UNIX）或<em>文件句柄</em>（Windows）</li>
</ul>
</li>
</ul>
</li>
<li>表中条目存储的信息：
<ul>
<li>文件指针，需要为每个进程单独保存</li>
<li>文件打开计数，文件被打开的数量。当计数为 0 时（文件未被使用），可删除条目</li>
<li>文件磁盘位置</li>
<li>访问权限</li>
</ul>
</li>
<li>打开文件的过程，
<ul>
<li>检索目录，检索到指定文件后，将其磁盘 inode 复制到活动 inode 表中</li>
<li>对比权限</li>
<li>为用户打开文件表和系统打开文件表创建表项，前者会包含指向后者表项的指针
<ul>
<li>一旦文件被打开，内核就不再使用文件名来访问文件，而是用文件描述符或文件句柄</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>文件保护，</p>
<ul>
<li>访问类型，对文件的保护可从限制访问类型出发
<ul>
<li>读、写、执行、添加、删除、列表清单（列出文件名和文件属性）</li>
</ul>
</li>
<li>访问控制，如何限制对文件的权限
<ul>
<li>根据用户身份，
<ul>
<li>访问控制列表（存取控制列表）（ACL, Access-Control List）
<ul>
<li>为每个文件和目录增设一个 ACL，以规定用户名所允许的访问类型</li>
</ul>
</li>
<li>精简的访问列表
<ul>
<li>三种用户类型：拥有者、组、其它</li>
<li>将所有者和所属组名写入到 FCB 中</li>
</ul>
</li>
</ul>
</li>
<li>使用口令和密码
<ul>
<li>口令，存储在 FCB 或索引结点（也就是系统中），不安全</li>
<li>密码，对文件进行加密，提供密匙进行解密。解密会耗费时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="42-目录与文件共享"><a class="markdownIt-Anchor" href="#42-目录与文件共享"></a> 4.2 目录与文件共享</h3>
<p>目录，就是在 4.1 中提到的文件目录，是文件目录项（FCB）的有序集合。</p>
<ul>
<li>目录管理需要实现 “按名存取”</li>
</ul>
<p>目录结构，分为以下几类，</p>
<ul>
<li>单级目录结构，整个文件系统只有一张目录表
<ul>
<li>实现了 “按名存取”，但不允许文件重名，且查找速度慢、不便于共享</li>
</ul>
</li>
<li>两级目录结构，
<ul>
<li>主文件目录（MFD, Master File Directory），一张</li>
<li>用户文件目录（UFD, User File Directory），若干，与主文件目录构成两级结构</li>
<li>便于多用户使用，允许不同用户文件重名。但仍不缺乏灵活性，允许对文件分类</li>
</ul>
</li>
<li>树形目录结构，最为常用
<ul>
<li>绝对路径、相对路径、当前目录（工作目录）</li>
<li>会多次访问硬盘</li>
</ul>
</li>
<li>无环图目录结构，在属性目录结构的基础上，增加一些指向同一结点的有向边
<ul>
<li>便于实现文件共享。文件或目录指向哪个结点就说明共享给谁</li>
<li>若要取消共享，需要等待没有其它共享用户访问时，再删去结点
<ul>
<li>设置一个共享计数器，增加共享链就加 1，删除共享链就减 1。直到为 0 才能删结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目录操作，</p>
<ul>
<li>搜索目录，创建文件（增加目录项），删除文件（删除目录项），创建目录，删除目录，移动目录，显示目录（例如显示所有文件及属性），修改目录（文件属性被保存在目录项中）</li>
</ul>
<p>目录检索，在目录中查找某个文件的方法，</p>
<ul>
<li>线性列表，实现线性查找</li>
<li>哈希表，实现散列查找。快，但要解决冲突</li>
</ul>
<p>文件共享，两种方法如下，</p>
<ul>
<li>基于索引结点的共享方式（硬链接）
<ul>
<li>文件目录的目录项，由文件名和指向索引结点的指针构成</li>
<li>两个文件目录的目录项，指针指向同一个索引结点</li>
<li>链接计数，索引结点中统计对应文件被引用次数的变量
<ul>
<li>即，从一个索引结点创建硬链接后，原索引结点和被创建的索引结点的链接计数都加 1</li>
</ul>
</li>
</ul>
</li>
<li>利用符号链实现文件共享（软连接）
<ul>
<li>LINK 类型文件，仅包含被链接文件的路径名</li>
<li>会复制索引结点。原文件索引结点的后续变化不会影响到这里，包括链接计数的改动</li>
<li>比起硬链接，因为是基于路径，所以要多次访问硬盘，更慢一些</li>
</ul>
</li>
</ul>
<h3 id="43-文件系统"><a class="markdownIt-Anchor" href="#43-文件系统"></a> 4.3 文件系统</h3>
<p>文件系统，提供从磁盘读写文件的便捷方法。</p>
<p>文件系统层次结构，以程序到设备的顺序列举：</p>
<ul>
<li>逻辑文件系统，管理元数据信息而不包括实际数据，即维护逻辑上的目录结构
<ul>
<li>通过文件控制块 FCB 维护文件结构</li>
</ul>
</li>
<li>文件组织模块，组织文件的逻辑块、物理块，可转换逻辑块地址和物理块地址</li>
<li>基本文件系统，向设备发给送命令，以读写物理块
<ul>
<li>对缓冲区进行管理。与性能息息相关</li>
</ul>
</li>
<li>I/O 控制，包括设备驱动程序和中断处理程序，在内存与外存之间传输信息</li>
</ul>
<p>文件系统布局，磁盘上每个分区都能有独立的文件系统，</p>
<ul>
<li>在磁盘中的结构。<strong>磁盘上每个分区都有独立的文件系统</strong>，被称为<em>卷</em>（volume）
<ul>
<li>主引导记录（MBR, Master Boot Record），位于磁盘的 0 号扇区
<ul>
<li>告诉去硬盘哪个分区加载操作系统。BIOS 读入并执行 MBR</li>
<li>MBR 做的第一件事是确定活动分区，读入活动分区的第一块（引导块）</li>
</ul>
</li>
<li>分区表，紧挨着 MBR 之后
<ul>
<li>给出每个分区的起始和结束地址</li>
<li>表其中一个分区被标记为活动分区</li>
</ul>
</li>
<li>在一个磁盘分区内：
<ul>
<li>引导块（boot block）/ 引导扇区，每个分区都以一个引导块开始，即使不含有操作系统</li>
<li>超级块（super block），紧挨着引导块之后，描述了文件系统
<ul>
<li>包含文件系统的所有关键信息</li>
<li>在计算机启动，或该文件系统首次使用时，超级块会被载入内存</li>
<li>包含的信息：块的数量、块的大小、空闲块数量和指针、空闲的 FCB 数量等</li>
</ul>
</li>
<li>空闲空间管理，紧挨着超级块之后，指示空闲块的信息（块状态、空闲块位置）
<ul>
<li>可以用位示图或指针链接的形式给出</li>
</ul>
</li>
<li>之后可能跟着一组 i 结点，每个文件指向一个结点；然后是根目录、其它文件</li>
</ul>
</li>
</ul>
</li>
<li>在内存中的结构。内存中的信息用于管理文件系统，并提供缓存提高性能，
<ul>
<li>相关数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃</li>
<li>相关数据的结构类型可能包括：
<ul>
<li>安装表（mount table），包含每个已安装文件系统分区的相关信息</li>
<li>目录信息</li>
<li>整个系统的打开文件表，只有一个，包含所有被打开文件的 FCB 副本和其它信息</li>
<li>每个进程的打开文件表，不止一个，内有指向系统文件表中条目的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>卷（volume），包含文件系统的分区。</p>
<ul>
<li>卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成的 RAID 集</li>
<li>在一个卷中，存放 FCB 的空间（目录区）和文件数据的空间（文件区）是分离的</li>
</ul>
<p>外存的空闲空间管理，以针对空闲物理块的方式管理外存，</p>
<ul>
<li>空闲表法，建立一张空闲盘块表，指示每个空闲区域的起始盘块号（第一个盘块）和盘块数量
<ul>
<li>类似于内存的段式存储管理中的段表，记录始址和长度</li>
<li>所有空闲区按其起始盘块号递增的次序排序</li>
<li>分配方法，类似于内存的动态分配方法，也有首次适应算法之类</li>
<li>回收方法，同样类似于内存的回收，需要考虑前后相邻的空闲区</li>
</ul>
</li>
<li>空闲链表法，使用链表记录空闲区或空闲盘块
<ul>
<li>空闲盘块链，以盘块为单位进行链接</li>
<li>空闲盘区链，以空闲盘区为单位进行链接</li>
</ul>
</li>
<li>位示图法（位向量表），利用二进制的一位来表示一个盘块的使用情况。0 为空闲 1 为已分配
<ul>
<li>每一位被称为位向量。所以位示图也被称为 <em>位向量表</em></li>
<li>比起空闲表和空闲链表，位示图法更适用于大型文件系统</li>
</ul>
</li>
<li>成组链接法，由若干成组链块链接而成（UNIX 系统采用）
<ul>
<li>成组链块，存放了一组空闲盘块号的盘块。数量有上限</li>
<li><strong>成组链块指向的最后一个空闲盘块，会作为另一个成组链块存储下一组盘块号</strong>。如是循环</li>
<li>盘块的分配：查阅第一个成组链块。若指向了最后一个盘块，则跳转到下一个成组链块</li>
</ul>
</li>
<li>关于超级块：位向量表或第一个成组链块，以及目录区文件区划分信息都要存放其中</li>
</ul>
<p>虚拟文件系统（VFS），抽象出一个通用的文件系统模型，屏蔽了不同文件系统的差异。</p>
<ul>
<li>用户程序通过 VFS 提供的同一调用函数来操作不同文件系统</li>
<li>严格来说不是一种文件系统，它只存在于内存中</li>
<li>为了实现 VFS，Linux 主要抽象为了四种对象类型：
<ul>
<li>超级块对象，对应于分区的超级块</li>
<li>索引结点对象，包含处理文件所需要的所有信息</li>
<li>目录项对象，并不是实际在硬盘上存在的数据结构。可提高切换目录的速度</li>
<li>文件对象，代表进程打开的一个文件
<ul>
<li>一般多个文件对象共用一个目录项对象</li>
</ul>
</li>
</ul>
</li>
<li>通过 VFS 将常用对象进行缓存，可以提高系统性能</li>
</ul>
<p>分区，一个磁盘可以划分多个分区。</p>
<ul>
<li>没有文件系统的分区是 “原始的”。UNIX 可以直接使用原始磁盘格式</li>
</ul>
<h2 id="第五章-输入输出io管理"><a class="markdownIt-Anchor" href="#第五章-输入输出io管理"></a> 第五章 输入输出（I/O）管理</h2>
<h3 id="51-io-管理概述"><a class="markdownIt-Anchor" href="#51-io-管理概述"></a> 5.1 I/O 管理概述</h3>
<p>I/O 设备，数据交换设备。</p>
<ul>
<li>设备的分类
<ul>
<li>按信息交换的单位分类，
<ul>
<li>块设备，属于有结构设备，例如磁盘
<ul>
<li>速度高、可寻址，即可随机读写</li>
</ul>
</li>
<li>字符设备，属于无结构类型，例如打印机
<ul>
<li>速度慢、不可寻址</li>
</ul>
</li>
</ul>
</li>
<li>按传输速度分类，
<ul>
<li>低速设备，每秒仅传输几百字节，例如键盘鼠标</li>
<li>中速设备，每秒传输成千上万字节，例如打印机</li>
<li>告诉设备，每秒传输数兆以上字节，例如硬盘、光盘机</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>设备控制器（I/O 控制器），位于 CPU 与设备之间，</p>
<ul>
<li>主要功能：接收 CPU 命令、反映设备状态、进行数据交换、进行地址识别</li>
<li>组成：
<ul>
<li>设备控制器与 CPU 的接口
<ul>
<li>含有三类信息线：数据线（存取数据）、地址线（指明要操作的设备）、控制线</li>
</ul>
</li>
<li>设备控制器与设备的接口
<ul>
<li>一个设备控制器可以连接多个设备，因此会有多个设备的接口</li>
<li>对于每个设备，都存在数据、控制、状态三种类型的端口，或是说寄存器</li>
</ul>
</li>
<li>I/O 逻辑，负责识别 CPU 命令，实现 CPU 对设备的控制</li>
</ul>
</li>
<li><strong>I/O 端口</strong>，可被 CPU 直接访问的寄存器
<ul>
<li>主要有三类：
<ul>
<li>数据寄存器，实现 CPU 与外部设备的数据缓冲</li>
<li>状态寄存器，指示设备的状态和执行结果</li>
<li>控制寄存器，CPU 写入后可以控制设备模式</li>
</ul>
</li>
<li>为了让 CPU 可访问，I/O 端口有两种<strong>编址方式</strong>：
<ul>
<li>独立编址，端口地址按设备进行划分，每次从 0 地址开始独立编址</li>
<li>统一编址，又称内存映射 I/O，端口被映射到内存地址。对内存读写即对端口读写</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>I/O 控制方式，如何与 I/O 端口交换信息，</p>
<ul>
<li>程序直接控制方式。需要反复查询设备是否准备好，造成 CPU 资源的浪费</li>
<li>中断驱动方式，允许 I/O 设备向 CPU 发出中断信号
<ul>
<li>CPU 向 I/O 设备发出指令后转去执行其它程序，直到接收中断信号再回到原程序</li>
</ul>
</li>
<li>DMA 方式，使用专门的 DMA 控制器 代替 CPU 控制总线
<ul>
<li>DMA（Direct Memory Access，直接存储器存取）</li>
<li>跳过 CPU 的参与，内存直接存取，速度更快</li>
<li>DMA 控制器需要设置 4 类寄存器：
<ul>
<li>命令/状态寄存器（CR），设备状态与相关控制命令信息</li>
<li>内存地址寄存器（MAR），内存始址</li>
<li>数据寄存器（DR），暂存的要交互的数据</li>
<li>数据计数器（DC），本次要传输的数量</li>
</ul>
</li>
<li>比起上面的中断驱动方式，此时只在传输完毕才会发生中断，而不是传一下中断一下</li>
</ul>
</li>
<li>通道控制方式，使用 I/O 通道（一种处理机）进一步减少 CPU 干预
<ul>
<li>比起 DMA，将读写的单位从一个数据块变为了一组数据块</li>
<li>本质是通道帮忙控制了设备控制器</li>
</ul>
</li>
</ul>
<p>I/O 软件的层次结构，从上往下的顺序：</p>
<ul>
<li>用户层 I/O 软件，在用户层提供的、与 I/O 操作有关的库函数</li>
<li>设备独立性软件，设备独立性也称设备无关性，使应用程序独立于具体使用的物理设备
<ul>
<li>用逻辑设备名使用某类设备，在系统实际执行时再映射为物理设备名</li>
<li>提供统一接口，使得任何设备都有相同的接口</li>
</ul>
</li>
<li>设备驱动程序，与硬件直接相关，应为每类设备配置一个设备驱动程序
<ul>
<li>起到封装设备细节的作用</li>
</ul>
</li>
<li>中断保护程序，位于系统底层，对用户来说无感</li>
<li>硬件</li>
</ul>
<p>根据设备类型，划分 I/O 接口：</p>
<ul>
<li>字符设备接口
<ul>
<li>提供 <code>get</code> <code>put</code> 操作，操作字符设备的字符缓冲区</li>
<li>提供 <code>in-control</code>，统一的、对设备进行操作的指令</li>
<li>字符设备都属于独占设备，需要实现互斥共享</li>
</ul>
</li>
<li>块设备接口
<ul>
<li>使用系统调用，将设备文件映射到内存，返回副本在内存的地址。设备读写转为内存读写</li>
</ul>
</li>
<li>网络设备接口，许多系统提供的网络 I/O 接口为网络套接字接口</li>
<li>阻塞/非阻塞 I/O
<ul>
<li>阻塞 I/O，用户进程在调用 I/O 时会被阻塞，等待 I/O 操作完成</li>
<li>非阻塞 I/O，用户进程重复查询 I/O 操作</li>
</ul>
</li>
</ul>
<h3 id="52a-高速缓存-缓冲区"><a class="markdownIt-Anchor" href="#52a-高速缓存-缓冲区"></a> 5.2A 高速缓存、缓冲区</h3>
<p>磁盘高速缓存，盘块驻留在内存中，</p>
<ul>
<li>在内存有两种形式：单独开辟一块固定的空间；将空闲内存空间作为一个缓冲池</li>
</ul>
<p>缓冲区，</p>
<ul>
<li>硬件缓冲器；位于内存的缓冲区（最常用）</li>
<li>缓冲区的作用：缓和 CPU 与 I/O 设备速度的不匹配；减少 CPU 中断；解决数据粒度不匹配；提高 CPU 与 I/O 设备之间的并行性</li>
<li>根据系统设置缓冲器的个数，可分为：
<ul>
<li>单缓冲，主存中有一个缓冲区
<ul>
<li>注意：<strong>同一个缓冲不允许同时存取</strong>，另一方需等待</li>
</ul>
</li>
<li>双缓冲，设置两个并联的缓冲区，避免一方闲着
<ul>
<li>在题目中为了方便计算时间，可以假设一个缓冲区为空一个缓冲区为满</li>
</ul>
</li>
<li>循环缓冲，多个大小相等的缓冲区通过指针形成环形（类似循环链表）
<ul>
<li>设置两个指针 <code>in</code> <code>out</code>，使得存取可以同时进行（类似循环队列）</li>
<li>要为输入（从外设到内存）和输出（从内存到外设）各自设置一个循环缓冲</li>
</ul>
</li>
<li>缓冲池，使用多个缓冲区，利用指针形成输入队列和输出队列
<ul>
<li>以输入为例，过程如下：
<ul>
<li>从空缓冲队列中选出一块，作为 “收容输入数据的工作缓冲区”</li>
<li>数据输入到这个缓冲区内，然后将该缓冲区接在输入队列尾部</li>
</ul>
</li>
<li>可见，缓冲区们被划分为了三个队列，
<ul>
<li>空缓冲队列</li>
<li>装满输入数据的缓冲队列（输入队列）</li>
<li>装满输出数据的缓冲队列（输出队列）</li>
</ul>
</li>
<li>针对数据的输入与输出，这些缓冲区有自己的名字：
<ul>
<li>用于收容输入数据的工作缓冲区 <code>hin</code>（外设数据输入到缓冲池）</li>
<li>用于提取输入数据的工作缓冲区 <code>sin</code>（提取缓冲池中的外设输入数据）</li>
<li>用于收容输出数据的工作缓冲区 <code>hout</code>（内存数据输出到缓冲池）</li>
<li>用于提取输出数据的工作缓冲区 <code>sout</code>（提取缓冲池中的内存输出数据）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="52b-设备独立性-设备管理-spooling-技术"><a class="markdownIt-Anchor" href="#52b-设备独立性-设备管理-spooling-技术"></a> 5.2B 设备独立性、设备管理、SPOOLing 技术</h3>
<p>设备独立性软件，又称设备无关软件，实现与硬件个体差异无关的功能（区分于设备驱动）。</p>
<ul>
<li>位于设备驱动程序的前一层</li>
<li>设备独立性，应用程序独立于具体使用的物理设备
<ul>
<li>为了实现设备独立性：
<ul>
<li>系统有一张逻辑设备表（LUT），用于将逻辑设备名映射为物理设备名</li>
<li>LUT 表项包括 逻辑设备名、物理设备名、设备驱动程序入口</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>设备的分配与回收，</p>
<ul>
<li>设备的分类，
<ul>
<li>独占式使用设备、分时式共享使用设备、以 SPOOLing 方式使用外部设备</li>
</ul>
</li>
<li>控制表：
<ul>
<li>设备控制表（DCT），一张表对应一个设备，记录设备状态
<ul>
<li>设备类型、设备标识符（物理设备名）、设备状态、设备控制器表指针、进程队列……</li>
</ul>
</li>
<li>控制器控制表（COCT），一张表对应一个设备控制器，记录设备控制器状态
<ul>
<li>控制器标识符（唯一ID）、控制器状态、通道表指针、进程队列……</li>
</ul>
</li>
<li>通道控制表（CHCT），一张表对应一个通道，记录通道状态
<ul>
<li>通道标识符、通道状态、控制器表首地址（所管理的控制器的信息）、进程队列……</li>
</ul>
</li>
<li>系统设备表（SDT），只有一张，记录所有物理设备的情况
<ul>
<li>设备类型、设备标识符、DCT、驱动程序入口……</li>
</ul>
</li>
</ul>
</li>
<li>设备的分配过程：
<ul>
<li>根据物理设备名在 SDT 中查找，依次得到 DCT、COCT、CHCT</li>
<li>若设备正忙，将进程 PCB 附在 DCT 中的设备等待队列中；若设备空闲则直接分配</li>
<li>若控制器正忙，将进程 PCB 附在 COCT 中的控制器等待队列中；若控制器空闲则直接分配</li>
<li>若通道正忙，将进程 PCB 附在 CHCT 中的通道等待队列中；若通道空闲则直接分配</li>
<li>只有当设备、控制器、通道三者都分配成功，才算是完成了设备分配</li>
</ul>
</li>
<li>设备分配的安全性，是指分配过程硬防止发生进程死锁
<ul>
<li>安全分配方式，进程发出 I/O 请求便被阻塞，直到 I/O 操作完成</li>
<li>不安全分配方式，进程发出 I/O 请求后继续运行，仅当进程所请求的设备正忙才被阻塞</li>
</ul>
</li>
</ul>
<p>SPOOLing 技术（假脱机技术），可将独占设备改造为共享设备。</p>
<ul>
<li>组成：
<ul>
<li>输入井、输出井，在外存（往往是硬盘）上开辟两个区域，收容输入与输出数据
<ul>
<li>每次对设备的输入或输出，都会先排在井中的队列</li>
<li><strong>将用户程序对外设的交互，转变为对硬盘的交互</strong></li>
</ul>
</li>
<li>输入缓冲区、输出缓冲区，在内存上开辟两个区域
<ul>
<li>输入缓冲，暂存输入设备送来的数据，将会再被送到输入井</li>
<li>输出缓冲，暂存从输出井送来的数据，将会被传送到输出设备</li>
<li>也就是说，外设实际上还是和主存进行交互。硬盘的井仅用来堆积存放</li>
</ul>
</li>
<li>输入进程、输出进程，模拟外围控制机的输入与输出</li>
</ul>
</li>
<li>如此，进程的设备请求会在写入输出井后完成，但真正的执行会在稍后进行</li>
<li>可以说 SPOOLing 技术是 “以空间换取时间的技术”</li>
</ul>
<h3 id="53-磁盘-固态硬盘"><a class="markdownIt-Anchor" href="#53-磁盘-固态硬盘"></a> 5.3 磁盘、固态硬盘</h3>
<p>磁盘，用物理盘片进程存储。</p>
<ul>
<li>磁盘的物理结构，
<ul>
<li>柱面，所有盘面中相对位置相同的所有磁道，整体就像是一个圆柱体</li>
<li>盘面，每个盘片有两个盘面</li>
<li>磁道，盘面上的一圈圈同心圆，存放数据</li>
<li>扇区，磁道被划分为若干扇区
<ul>
<li>是按固定的圆心角度进行划分，所以越靠近圆心扇区越小</li>
<li>磁盘的存储能力受限于最内扇区的最大记录密度</li>
</ul>
</li>
<li><strong>0 号柱面，最外围的柱面</strong></li>
</ul>
</li>
<li>磁盘地址，用 “柱面号 - 盘面号 - 扇区号” 表示</li>
<li>磁盘的划分，
<ul>
<li>固定头磁盘（每个磁道都有一个磁头），活动头磁盘</li>
<li>可换盘磁盘，固定盘磁盘</li>
</ul>
</li>
</ul>
<p>磁盘的管理，初始化、引导块、坏块</p>
<ul>
<li>磁盘的初始化，
<ul>
<li>过程：
<ul>
<li>低级格式化 / 物理格式化，即划分扇区</li>
<li>分区，每个分区由若干柱面组成</li>
<li>逻辑格式化，即创建文件系统，操作系统将文件系统数据存储到磁盘上</li>
</ul>
</li>
<li>簇（Linux 中叫 “块”），操作系统将多个相邻扇区组合在一起
<ul>
<li>提高效率，便于更高效地管理磁盘</li>
<li>文件所占用的空间只能是簇的整倍数</li>
</ul>
</li>
</ul>
</li>
<li>引导块（启动块/启动分区），存放完整的计算机启动的初始化程序
<ul>
<li>初始化程序（自举程序），初始化 CPU、寄存器、设备控制器和内存等，接着启动系统
<ul>
<li>计算机从引导 ROM 读取代码，将引导块读入内存并执行</li>
<li>引导块一般位于第 0 号扇区，其存储的代码被称为 <em>主引导记录 MBR</em></li>
<li>主引导记录，除了包含引导代码，还包含磁盘分区表和标识引导分区的标志
<ul>
<li>引导分区包含操作系统本体</li>
</ul>
</li>
<li>找到引导分区后会读取分区的第一个扇区，称为引导扇区。继续引导过程</li>
</ul>
</li>
<li>具有启动分区的磁盘被称为 <em>启动磁盘</em> 或 <em>系统磁盘</em></li>
</ul>
</li>
<li>坏块处理，对损坏的扇区进行处理
<ul>
<li>对于简单磁盘，可在逻辑格式化（建立系统文件）时检测坏块，并在 FAT 表上标识
<ul>
<li>是操作系统进行的维护</li>
</ul>
</li>
<li>对于复杂的磁盘，则是由磁盘控制器维护一个坏块列表。系统无法察觉坏块
<ul>
<li>列表在出厂低级格式化时就已经初始化，在磁盘使用过程中不断更新</li>
<li>扇区备用，保留一些块作为 <em>备用扇区</em>，用于替换坏块</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>磁盘调度算法，磁头如何查找数据，</p>
<ul>
<li>一些指标，
<ul>
<li>寻找时间，磁头移动到指定磁道所需时间。包括启动磁头、移动磁头
<ul>
<li>最耗时，影响到效率</li>
</ul>
</li>
<li>旋转延迟，磁头定位到某一扇区所需时间，一般为转动一圈所需时间的一半</li>
<li>传输时间，从磁盘读出或写入数据所经历的时间</li>
</ul>
</li>
<li>磁盘调度算法
<ul>
<li>先来先服务 FCFS（First Come First Serve）</li>
<li>最短寻道时间优先 SSTF（Shortest Seek Time First）
<ul>
<li>总是先执行 <em>查找时间最短</em> 的那个磁盘请求</li>
<li>可能会导致饥饿——离磁头位置远的服务被无限期推迟</li>
</ul>
</li>
<li>扫描算法 SCAN
<ul>
<li>每次总选择沿臂 <em>本次移动方向</em> 最近的那个柱面</li>
<li>不利于远离磁头一端的访问请求</li>
</ul>
</li>
<li>循环扫描算法 CSCAN
<ul>
<li>移动臂总是从 0 号柱面至最大柱面顺序扫描，然后直接返回 0 号柱面重复循环</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>固态硬盘，基于闪存的存储器。</p>
<ul>
<li>随机写很慢，因为是按块的单位进行读写，块中原有的信息要进行转移</li>
<li>随机读很快</li>
<li>磨损均衡，弥补 SSD 的寿命缺陷，
<ul>
<li>动态磨损均衡，读写时自动选择较新的闪存块</li>
<li>静态磨损均衡，一直检测并自动进行数据分配，使得寿命损耗得到均衡。效果更好</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">HiDolen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/[object%20Object]/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">http://example.com/[object%20Object]/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">时间·线</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">课堂笔记</a><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94/">考研</a><a class="post-meta__tags" href="/tags/408/">408</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86C/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86C/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">通信原理C</div></div></a></div><div class="next-post pull-right"><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">数据结构</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">计算机组成原理</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">计算机网络</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" title="概率论与数理统计"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">概率论与数理统计</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="线性代数"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">线性代数</div></div></a></div><div><a href="/%5Bobject%20Object%5D/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/%E8%80%83%E7%A0%94/%E6%95%B0%E5%AD%A6/%E9%AB%98%E6%95%B0/%E4%B8%80%E4%BA%9B%E5%85%AC%E5%BC%8F/" title="一些公式"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">一些公式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HiDolen</div><div class="author-info__description">HiDolen 的个人博客。平时写的笔记都在这里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">110</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> 第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1 操作系统的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2 操作系统的发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3 操作系统运行环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text"> 1.4 操作系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="toc-number">1.5.</span> <span class="toc-text"> 1.5 操作系统引导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.6.</span> <span class="toc-text"> 1.6 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text"> 第二章 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2 处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 进程切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3 同步与互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%AD%BB%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text"> 2.4 死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text"> 第三章 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1 内存管理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 进程与地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E5%88%86%E5%8C%BA-%E9%A1%B5%E5%BC%8F-%E6%AE%B5%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 内存的分配（分区、页式、段式）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 基于页面的管理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 抖动和工作集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 内存映射文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">3.2.4.</span> <span class="toc-text"> 地址翻译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 第四章 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2 目录与文件共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.3.</span> <span class="toc-text"> 4.3 文件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAio%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text"> 第五章 输入输出（I&#x2F;O）管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-io-%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1 I&#x2F;O 管理概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52a-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2A 高速缓存、缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52b-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86-spooling-%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.2B 设备独立性、设备管理、SPOOLing 技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E7%A3%81%E7%9B%98-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">5.4.</span> <span class="toc-text"> 5.3 磁盘、固态硬盘</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By HiDolen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>